<!DOCTYPE html>
<html>

<head>
    <title>HW2-Hierarchical Model</title>
    <meta charset="utf-8">
    <link rel="stylesheet" href="vendor/css/bootstrap.min.css">
    <link href="style.css" rel="stylesheet">
    <style>
        #canvas {
            margin-left: auto;
            margin-right: auto;
            display: block;
            width: 800px;
        }

        /* 增加button間距 */
        #navbtn button {
            margin: 0 10px;
        }
    </style>
</head>

<body>
    <nav class="navbar navbar-expand-lg navbar-dark bg-dark">
        <div class="container">
            <span class="navbar-brand">Hierarchical Model</span>
            <div class="collapse navbar-collapse">
                <ul class="navbar-nav">
                    <li class="nav-item">
                        <a class="nav-link" href="index.html">Home</a>
                    </li>
                </ul>
            </div>
        </div>
    </nav>
    <div id="canvas"></div>
    <script src="vendor/js/jquery-3.3.1.min.js"></script>
    <script src="vendor/js/bootstrap.min.js"></script>
    <script src="vendor/js/KeyboardState.js"></script>
    <script src="https://threejs.org/build/three.min.js"></script>
    <script src="https://raw.githack.com/mrdoob/three.js/dev/examples/js/loaders/MTLLoader.js"></script>
    <script src="https://raw.githack.com/mrdoob/three.js/dev/examples/js/loaders/OBJLoader.js"></script>
    <script src="https://raw.githack.com/mrdoob/three.js/dev/examples/js/loaders/GLTFLoader.js"></script>
    <script src="https://threejs.org/examples/js/controls/OrbitControls.js"></script>
    <script>
        //檢查FPS
        javascript: (function () { var script = document.createElement('script'); script.onload = function () { var stats = new Stats(); document.body.appendChild(stats.dom); requestAnimationFrame(function loop() { stats.update(); requestAnimationFrame(loop) }); }; script.src = 'https://mrdoob.github.io/stats.js/build/stats.min.js'; document.head.appendChild(script); })();
        //必要全域變數
        var scene, camera, renderer;
        var ambientLight, dLight;
        var finish = false;
        var objNameList = [];
        init();
        animate();

        function init() {
            scene = new THREE.Scene();
            let width = window.innerWidth * 0.9;
            let height = window.innerHeight * 0.9;
            $("#canvas").width(width);
            $("#canvas").height(height);
            renderer = new THREE.WebGLRenderer();
            renderer.setSize(width, height);
            renderer.setClearColor('green');
            //陰影
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            $('#canvas').append(renderer.domElement);
            camera = new THREE.PerspectiveCamera(
                80,
                width / height,
                1,
                1000);
            camera.position.x = 0;
            camera.position.y = 50;
            camera.position.z = -100;
            ////////////////////////////////////////////////////////////////

            //環境光源
            ambientLight = new THREE.AmbientLight(0xdddddd);
            scene.add(ambientLight);

            //純喫茶
            let tryittea = buildModel();
            tryittea.castShadow = true;
            tryittea.receiveShadow = true;
            tryittea.position.set(-135, 41, 105);
            tryittea.rotation.y = -Math.PI / 6;
            scene.add(tryittea);

            //讀取開關
            readModel("switch", 'switch', 8, scene);
            objNameList.push('switch');
            //讀取椅子
            readModel("Chair", 'Chair', 55, scene);
            objNameList.push('Chair');
            //讀取檯燈
            readModel("Lamp", 'lamp', 30, scene, true);
            objNameList.push('lamp');
            //讀取測試檯燈
            readModel("test", 'test', 60, scene, true);
            objNameList.push('test');
            //讀取測試檯燈
            readModel("Lamp1", 'Lamp1', 20, scene);
            objNameList.push('Lamp1');
            //吊燈與室內燈源
            ceilLamp = new THREE.Object3D();
            //讀取吊燈
            readModel("Brass_Freak", 'ceilLamp', 60, ceilLamp);
            objNameList.push('ceilLamp');

            // directional light
            dLight = new THREE.DirectionalLight(0xffffff, 0.5);
            dLight.castShadow = true;
            dLight.shadow.camera.left = -150;
            dLight.shadow.camera.top = -125;
            dLight.shadow.camera.right = 150;
            dLight.shadow.camera.bottom = 125;
            dLight.shadow.camera.near = 5;
            dLight.shadow.camera.far = 250;
            dLight.target = scene;
            dLight.shadow.mapSize.width = dLight.shadow.mapSize.height = 512;
            dLight.shadow.bias = -.01;
            dLight.name = 'dirLight';

            dLight.position.y = -110;
            //把方向光加進吊燈組裡
            ceilLamp.add(dLight);
            ceilLamp.position.y = 200;
            scene.add(ceilLamp);

            //地板
            //https://www.3dxo.com/textures/4961_wood_8
            let planeMat = new THREE.TextureLoader().load('vendor/textures/wood.jpg');
            planeMat.wrapS = THREE.RepeatWrapping;
            planeMat.wrapT = THREE.RepeatWrapping;
            planeMat.repeat.set(18, 15);
            let plane = new THREE.Mesh(new THREE.PlaneGeometry(300, 250, 4, 4),
                new THREE.MeshLambertMaterial({
                    side: THREE.DoubleSide, // 雙面材質
                    map: planeMat,
                    color: 0xF0F0F0,//調整亮度到跟skybox相近
                }));
            plane.rotation.x -= Math.PI / 2;
            //地板可以出現影子
            plane.receiveShadow = true;
            scene.add(plane);
            //牆壁
            let walls = [
                createWall(true, 300),
                createWall(true, 300),
                createWall(false, 250),
                createWall(false, 250)
            ];
            walls[0].position.z = 126;
            walls[1].position.z = -126;
            walls[2].position.x = 151;
            walls[3].position.x = -151;
            walls.forEach(function (wall) {
                wall.castShadow = true;
                wall.receiveShadow = true;
                scene.add(wall);
            });
            //桌子
            let desk = createDesk();
            desk.position.set(-110, 0, 95);
            scene.add(desk);
            //天花板
            let celing = new THREE.Mesh(
                new THREE.BoxGeometry(2, height, width),
                new THREE.MeshLambertMaterial({
                    color: 'beige'
                })
            );
            let penbox = createPenBox();
            penbox.position.set(-105, 41, 110);
            scene.add(penbox);
            //歐逼康啜
            let controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.name = 'controls';
            // 禁用方向鍵調整歐逼康輟位置
            controls.enableKeys = false;
        }
        function createDesk() {
            let desk = new THREE.Object3D;
            let material = new THREE.MeshLambertMaterial({
                color: 'brown'
            });
            let desktop = new THREE.Mesh(new THREE.BoxGeometry(80, 2, 60), material);
            desktop.position.y = 40;
            let c1 = new THREE.Mesh(new THREE.CylinderGeometry(1.5, 1.5, 40, 30), material);
            let c2 = new THREE.Mesh(new THREE.CylinderGeometry(1.5, 1.5, 40, 30), material);
            let c3 = new THREE.Mesh(new THREE.CylinderGeometry(1.5, 1.5, 40, 30), material);
            let c4 = new THREE.Mesh(new THREE.CylinderGeometry(1.5, 1.5, 40, 30), material);
            c1.position.set(35, 20, 25);
            c2.position.set(35, 20, -25);
            c3.position.set(-35, 20, -25);
            c4.position.set(-35, 20, 25);
            desk.add(desktop, c1, c2, c3, c4);
            desk.traverse(function (obj) {
                obj.castShadow = true;
                obj.receiveShadow = true;
            });
            return desk;
        }
        function createWall(rotation, width = 300, height = 200) {
            let wall = new THREE.Mesh(
                new THREE.BoxGeometry(2, height, width),
                new THREE.MeshLambertMaterial({
                    color: 'beige'
                })
            );
            wall.position.y = height / 2;
            if (rotation) {
                wall.rotation.y = Math.PI / 2;

            }
            wall.receiveShadow = true;
            return wall;
        }

        function createPenBox() {
            let penBox = new THREE.Object3D();
            let texture = new THREE.TextureLoader().load('vendor/textures/woodcutout.png')
            let material = new THREE.MeshPhongMaterial({ side: THREE.DoubleSide, map: texture, alphaTest: 0.5 });
            let f1 = new THREE.Mesh(new THREE.BoxGeometry(6.05, 8, 0.05), material);
            let f2 = new THREE.Mesh(new THREE.BoxGeometry(6.05, 8, 0.05), material);
            let f3 = new THREE.Mesh(new THREE.BoxGeometry(6.05, 8, 0.05), material);
            let f4 = new THREE.Mesh(new THREE.BoxGeometry(6.05, 8, 0.05), material);
            let f5 = new THREE.Mesh(new THREE.BoxGeometry(6, 6, 0.05), material);
            f1.position.set(3, 4, 0);
            f2.position.set(-3, 4, 0);
            f3.position.set(0, 4, 3);
            f4.position.set(0, 4, -3);
            f1.rotation.y = Math.PI / 2;
            f2.rotation.y = Math.PI / 2;
            f5.rotation.x = Math.PI / 2;
            penBox.add(f1, f2, f3, f4, f5);
            penBox.traverse(function (obj) {
                obj.castShadow = true;
                obj.receiveShadow = true;
            });
            return penBox;
        }

        function createFace(one, two, three, index = 0) {
            let face = new THREE.Face3(one, two, three);
            face.materialIndex = index;
            return face;
        }

        function createTextureMaterial(map, alphaTest = 1) {
            //用Lambert，新鮮屋弄上油墨，不太反光ㄉ
            let material = new THREE.MeshLambertMaterial({
                map: map,
                alphaTest: alphaTest
            });
            return material;
        }

        function buildModel() {
            let geometry = new THREE.Geometry();
            //斜邊高度
            let sq375 = Math.sqrt(3.75);

            //放入頂點
            geometry.vertices.push(new THREE.Vector3(-3.5, 0, 3.5));
            geometry.vertices.push(new THREE.Vector3(3.5, 0, 3.5));
            geometry.vertices.push(new THREE.Vector3(3.5, 10.5, 3.5));
            geometry.vertices.push(new THREE.Vector3(3.5, 10.5 + sq375, 0));
            geometry.vertices.push(new THREE.Vector3(-3.5, 10.5 + sq375, 0));
            geometry.vertices.push(new THREE.Vector3(-3.5, 10.5, 3.5));

            geometry.vertices.push(new THREE.Vector3(-3.5, 0, -3.5));
            geometry.vertices.push(new THREE.Vector3(3.5, 0, -3.5));
            geometry.vertices.push(new THREE.Vector3(3.5, 10.5, -3.5));
            geometry.vertices.push(new THREE.Vector3(-3.5, 10.5, -3.5));

            //中間一點讓兩邊可以上三角形做開喝飲料的位置
            geometry.vertices.push(new THREE.Vector3(0, 10.5 + sq375, 0));

            //最上面一條橫條黏膠的部分
            geometry.vertices.push(new THREE.Vector3(3.5, 10.5 + sq375 + 1.5, 0));
            geometry.vertices.push(new THREE.Vector3(-3.5, 10.5 + sq375 + 1.5, 0));

            //正面
            geometry.faces.push(createFace(0, 1, 2));
            geometry.faces.push(createFace(0, 2, 5));

            //背面
            geometry.faces.push(createFace(7, 6, 9));
            geometry.faces.push(createFace(7, 9, 8));

            //右面
            geometry.faces.push(createFace(1, 7, 8));
            geometry.faces.push(createFace(1, 8, 2));

            //左面
            geometry.faces.push(createFace(6, 0, 5));
            geometry.faces.push(createFace(6, 5, 9));

            //正面斜邊
            geometry.faces.push(createFace(5, 2, 3));
            geometry.faces.push(createFace(5, 3, 4));

            //背面斜邊
            geometry.faces.push(createFace(8, 9, 4));
            geometry.faces.push(createFace(8, 4, 3));

            //上面橫條
            geometry.faces.push(createFace(4, 3, 11));
            geometry.faces.push(createFace(4, 11, 12));
            //上面橫條後面
            geometry.faces.push(createFace(3, 4, 12));
            geometry.faces.push(createFace(3, 12, 11));

            /*----右面折進去的的三面，同一面----*/
            //靠前的背對的面
            geometry.faces.push(createFace(2, 10, 3));
            //中間的面
            geometry.faces.push(createFace(2, 8, 10));
            // //靠後的正對的面
            geometry.faces.push(createFace(8, 3, 10));

            /*----左面折進去的的三面，同一面----*/
            //靠後的正對的面
            geometry.faces.push(createFace(9, 10, 4));
            //中間的面
            geometry.faces.push(createFace(9, 5, 10));
            //靠前的背對的面
            geometry.faces.push(createFace(5, 4, 10));

            //底部
            geometry.faces.push(createFace(6, 7, 1));
            geometry.faces.push(createFace(6, 1, 0));

            //上材質
            //材質高度幾分之幾
            let h1 = 1035 / 1600;/*1035/1600 底部到斜邊*/
            let h2 = 1445 / 1600;/*1445/1600 斜邊到封條下*/
            let h3 = 7 / 16;/* 底下的正方形*/
            //正面
            geometry.faceVertexUvs[0].push([
                new THREE.Vector2(0, 0),
                new THREE.Vector2(0.2, 0),
                new THREE.Vector2(0.2, h1)
            ]);
            geometry.faceVertexUvs[0].push([
                new THREE.Vector2(0, 0),
                new THREE.Vector2(0.2, h1),
                new THREE.Vector2(0, h1)
            ]);
            //背面
            geometry.faceVertexUvs[0].push([
                new THREE.Vector2(0.4, 0),
                new THREE.Vector2(0.6, 0),
                new THREE.Vector2(0.6, h1)
            ]);
            geometry.faceVertexUvs[0].push([
                new THREE.Vector2(0.4, 0),
                new THREE.Vector2(0.6, h1),
                new THREE.Vector2(0.4, h1)
            ]);
            //右面
            geometry.faceVertexUvs[0].push([
                new THREE.Vector2(0.2, 0),
                new THREE.Vector2(0.4, 0),
                new THREE.Vector2(0.4, h1)
            ]);
            geometry.faceVertexUvs[0].push([
                new THREE.Vector2(0.2, 0),
                new THREE.Vector2(0.4, h1),
                new THREE.Vector2(0.2, h1)
            ]);
            //左面
            geometry.faceVertexUvs[0].push([
                new THREE.Vector2(0.6, 0),
                new THREE.Vector2(0.8, 0),
                new THREE.Vector2(0.8, h1)
            ]);
            geometry.faceVertexUvs[0].push([
                new THREE.Vector2(0.6, 0),
                new THREE.Vector2(0.8, h1),
                new THREE.Vector2(0.6, h1)
            ]);
            //正面斜邊
            geometry.faceVertexUvs[0].push([
                new THREE.Vector2(0, h1),
                new THREE.Vector2(0.2, h1),
                new THREE.Vector2(0.2, h2)
            ]);
            geometry.faceVertexUvs[0].push([
                new THREE.Vector2(0, h1),
                new THREE.Vector2(0.2, h2),
                new THREE.Vector2(0, h2)
            ]);
            //背面斜邊
            geometry.faceVertexUvs[0].push([
                new THREE.Vector2(0.4, h1),
                new THREE.Vector2(0.6, h1),
                new THREE.Vector2(0.6, h2)
            ]);
            geometry.faceVertexUvs[0].push([
                new THREE.Vector2(0.4, h1),
                new THREE.Vector2(0.6, h2),
                new THREE.Vector2(0.4, h2)
            ]);
            //上面橫條正面
            geometry.faceVertexUvs[0].push([
                new THREE.Vector2(0, h2),
                new THREE.Vector2(0.2, h2),
                new THREE.Vector2(0.2, 1)
            ]);
            geometry.faceVertexUvs[0].push([
                new THREE.Vector2(0, h2),
                new THREE.Vector2(0.2, 1),
                new THREE.Vector2(0, 1)
            ]);
            //上面橫條後面
            geometry.faceVertexUvs[0].push([
                new THREE.Vector2(0.4, h2),
                new THREE.Vector2(0.6, h2),
                new THREE.Vector2(0.6, 1)
            ]);
            geometry.faceVertexUvs[0].push([
                new THREE.Vector2(0.4, h2),
                new THREE.Vector2(0.6, 1),
                new THREE.Vector2(0.4, 1)
            ]);
            //右邊內凹
            geometry.faceVertexUvs[0].push([
                new THREE.Vector2(0.2, h1),
                new THREE.Vector2(0.3, h2),
                new THREE.Vector2(0.2, h2)
            ]);
            geometry.faceVertexUvs[0].push([
                new THREE.Vector2(0.2, h1),
                new THREE.Vector2(0.4, h1),
                new THREE.Vector2(0.3, h2)
            ]);
            geometry.faceVertexUvs[0].push([
                new THREE.Vector2(0.4, h1),
                new THREE.Vector2(0.4, h2),
                new THREE.Vector2(0.3, h2)
            ]);
            //左邊內凹
            geometry.faceVertexUvs[0].push([
                new THREE.Vector2(0.6, h1),
                new THREE.Vector2(0.7, h2),
                new THREE.Vector2(0.6, h2)
            ]);
            geometry.faceVertexUvs[0].push([
                new THREE.Vector2(0.6, h1),
                new THREE.Vector2(0.8, h1),
                new THREE.Vector2(0.7, h2)
            ]);
            geometry.faceVertexUvs[0].push([
                new THREE.Vector2(0.8, h1),
                new THREE.Vector2(0.8, h2),
                new THREE.Vector2(0.7, h2)
            ]);
            //底部
            geometry.faceVertexUvs[0].push([
                new THREE.Vector2(0.8, 0),
                new THREE.Vector2(1, 0),
                new THREE.Vector2(1, h3)
            ]);
            geometry.faceVertexUvs[0].push([
                new THREE.Vector2(0.8, 0),
                new THREE.Vector2(1, h3),
                new THREE.Vector2(0.8, h3)
            ]);
            //要先計算Face然後再計算頂點，這樣才能知道要光源要怎計算
            geometry.computeFaceNormals();
            geometry.computeVertexNormals();

            let loader = new THREE.TextureLoader();
            loader.crossOrigin = '';
            let mergeTexture = loader.load('vendor/textures/TryItTea/tryittea.png');
            materialArray = [];
            materialArray.push(
                createTextureMaterial(mergeTexture, 0.5)
            );
            return new THREE.Mesh(geometry, materialArray);
        }

        function readModel(modelName, objName = 'OBJ', targetSize = 40, parent, turn = false) {

            var onProgress = function (xhr) {
                if (xhr.lengthComputable) {
                    var percentComplete = xhr.loaded / xhr.total * 100;
                    console.log(Math.round(percentComplete, 2) + '% downloaded');
                }
            };

            var onError = function (xhr) { };

            var mtlLoader = new THREE.MTLLoader();
            mtlLoader.setPath('vendor/models/' + modelName + '/');
            mtlLoader.load(modelName + '.mtl', function (materials) {

                materials.preload();

                var objLoader = new THREE.OBJLoader();
                objLoader.setMaterials(materials);
                objLoader.setPath('vendor/models/' + modelName + '/');
                objLoader.load(modelName + '.obj', function (object) {
                    theObject = unitize(object, targetSize, "OBJ");
                    // theObject.add(new THREE.BoxHelper(theObject));
                    theObject.name = objName;
                    theObject.traverse(function (object) {
                        if (object instanceof THREE.Mesh) {
                            object.castShadow = true
                            object.receiveShadow = true
                        }
                    })
                    //把這個model放入父層
                    parent.add(theObject);
                    //不須改變軸的方向
                    if (turn)
                        theObject.setRotationFromEuler(new THREE.Euler(0, 0, Math.PI / 2))
                }, onProgress, onError);

            });
        }

        ////////////////////////////////////////
        // wrap an Object3D around the given object
        // so that it is centered at +Y axis
        //
        function unitize(object, targetSize, objName) {

            // find bounding box of 'object'
            var box3 = new THREE.Box3();
            box3.setFromObject(object);
            var size = new THREE.Vector3();
            size.subVectors(box3.max, box3.min);
            var center = new THREE.Vector3();
            center.addVectors(box3.max, box3.min).multiplyScalar(0.5);

            console.log('center: ' + center.x + ', ' + center.y + ', ' + center.z);
            console.log('size: ' + size.x + ', ' + size.y + ', ' + size.z);

            // uniform scaling according to objSize
            var objSize = Math.max(size.x, size.y, size.z);
            var scaleSet = targetSize / objSize;
            var theObject = new THREE.Object3D();
            theObject.add(object);
            object.scale.set(scaleSet, scaleSet, scaleSet);
            object.position.set(-center.x * scaleSet, 0, -center.z * scaleSet);

            object.rotation.y = Math.PI / 2;
            // let axis = new THREE.AxesHelper(10);
            // theObject.add(axis);

            //get now size

            // carSize = size.multiplyScalar(scaleSet);

            return theObject;
        }

        function animate() {
            if (!finish) {
                let isOK = true;
                objNameList.forEach(function (name) {
                    if (scene.getObjectByName(name) === undefined) {
                        isOK = false;
                    }
                });
                if (isOK) {
                    scene.getObjectByName('switch').position.set(-150, 80, 20);
                    scene.getObjectByName('Chair').position.set(-115, 0, 65);
                    scene.getObjectByName('Chair').rotation.y = -Math.PI / 2;
                    scene.getObjectByName('lamp').position.set(-75, 41, 105);
                    scene.getObjectByName('lamp').rotation.y = Math.PI * 3 / 4;
                    finish = !finish;
                }
            } else {
                renderer.render(scene, camera);
            }
            requestAnimationFrame(animate);
        }
    </script>
</body>