<!DOCTYPE html>
<html>

<head>
    <title>HW2-Hierarchical Model</title>
    <meta charset="utf-8">
    <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css">
    <link href="style.css" rel="stylesheet">
    <style>
        #canvas {
            margin-left: auto;
            margin-right: auto;
            display: block;
            width: 800px;
        }

        /* 增加button間距 */
        #navbtn button {
            margin: 0 10px;
        }
    </style>
</head>

<body>

    <div id="canvas"></div>
    <script src="https://threejs.org/build/three.min.js"></script>
    <script src="https://threejs.org/examples/js/controls/OrbitControls.js"></script>
    <script src="https://code.jquery.com/jquery-2.1.4.min.js"></script>
    <script src="https://raw.githack.com/mrdoob/three.js/dev/examples/js/loaders/MTLLoader.js"></script>
    <script src="https://raw.githack.com/mrdoob/three.js/dev/examples/js/loaders/OBJLoader.js"></script>
    <script src="https://jyunming-chen.github.io/tutsplus/js/KeyboardState.js"></script>


    <script>
        //檢查FPS
        javascript: (function () { var script = document.createElement('script'); script.onload = function () { var stats = new Stats(); document.body.appendChild(stats.dom); requestAnimationFrame(function loop() { stats.update(); requestAnimationFrame(loop) }); }; script.src = 'https://mrdoob.github.io/stats.js/build/stats.min.js'; document.head.appendChild(script); })();
        //threejs必要
        var scene, camera, renderer;
        //時間差
        var clock;
        //胎痕
        var fetalMark;
        //車子相關
        var pos = new THREE.Vector3();
        var vel = new THREE.Vector3();
        var force = new THREE.Vector3();
        var power, angle;
        var loadFinish = false;
        //鍵盤事件
        var keyboard = new KeyboardState();

        (function () {
            Math.clamp = function (val, min, max) {
                return Math.min(Math.max(val, min), max);
            }
        })();

        init();
        animate();
        function init() {

            //場景
            scene = new THREE.Scene();
            //cubemap
            let cube = loadCubemap();
            scene.background = cube;

            // let width = window.innerWidth;
            // let height = window.innerHeight;
            let width = 800;
            let height = 600;

            //攝影機
            camera = new THREE.PerspectiveCamera(
                80,
                width / height,
                1,
                1000);
            camera.position.x = 50;
            camera.position.y = 50;
            camera.position.z = 50;
            camera.lookAt(scene.position);

            //renderer
            renderer = new THREE.WebGLRenderer();
            renderer.setSize(width, height);
            renderer.setClearColor('white');
            //陰影
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;

            $("#canvas").append(renderer.domElement);

            //歐逼康啜
            // controls = new THREE.OrbitControls(camera, renderer.domElement);
            // controls.name = 'controls';
            //禁用方向鍵調整歐逼康輟位置
            // controls.enableKeys = false;

            //THREE提供的物件(算時間)
            clock = new THREE.Clock();

            // directional light
            dLight = new THREE.DirectionalLight(0xffffff, 0.5);
            dLight.position.set(80, 160, -100);
            dLight.castShadow = true;
            dLight.shadow.camera.left = -280;
            dLight.shadow.camera.top = -260;
            dLight.shadow.camera.right = 280;
            dLight.shadow.camera.bottom = 200;
            dLight.shadow.camera.near = 1;
            dLight.shadow.camera.far = 400;
            dLight.target = scene;
            dLight.shadow.mapSize.width = dLight.shadow.mapSize.height = 1024;
            scene.add(dLight);
            dLight.shadow.bias = -.01;
            dLight.name = 'dirLight';
            scene.add(dLight);
            let ambientLight = new THREE.AmbientLight(0xaaaaaa);
            scene.add(ambientLight);
            let pointLight = new THREE.PointLight(0xffffff);
            pointLight.position.set(100, 200, -100);
            scene.add(pointLight);
            readModel("Lamborghini_Aventador", 'car');

            //地板
            let planeMat = new THREE.TextureLoader().load('textures/kasahara.png');
            planeMat.wrapS = THREE.RepeatWrapping;
            planeMat.wrapT = THREE.RepeatWrapping;
            planeMat.repeat.set(5, 5);
            let plane = new THREE.Mesh(new THREE.PlaneGeometry(2000, 2000, 4, 4),
                new THREE.MeshLambertMaterial({
                    side: THREE.DoubleSide, // 雙面材質
                    map: planeMat,
                    color: 0xF0F0F0,//調整亮度到跟skybox相近
                }));
            plane.rotation.x -= Math.PI / 2;
            //地板可以出現影子
            plane.receiveShadow = true;
            scene.add(plane);

            //輔助
            // gridxz = new THREE.GridHelper(200, 20, 'red', 'black');
            // scene.add(gridxz);
            // let axis = new THREE.AxesHelper(10000);
            // scene.add(axis);

            //車速與轉動角度
            power = 1.0;
            angle = 0.0;
        }

        function animate() {
            let car;
            //讓localToWorld可以正常使用
            scene.updateMatrixWorld();
            if (scene.getObjectByName("car") !== undefined) {
                loadFinish = !loadFinish;
            }
            if (loadFinish) {
                car = scene.getObjectByName("car");
                dirLight = scene.getObjectByName("dirLight");
                cameraPos = car.localToWorld(new THREE.Vector3(-40, 30, 0));
                dirLightPos = car.localToWorld(new THREE.Vector3(-100, 100, 0));
                camera.position.set(cameraPos.x, cameraPos.y, cameraPos.z);
                camera.lookAt(car.position);
                dirLight.lookAt(car.position);
                //算時間差
                var dt = clock.getDelta();
                update(dt);
                // car update
                car.position.copy(pos);
                car.rotation.y = angle;
            }
            renderer.render(scene, camera);
            requestAnimationFrame(animate);
        }

        function update(dt) {
            keyboard.update();
            if (vel.length() > 0) {
                angle = Math.atan2(-vel.z, vel.x); // update orientation
            }

            if (keyboard.pressed("space"))
                power = 0.1;
            if (keyboard.pressed("W")) {
                power *= 1.5;
            }
            //改為倒車
            if (keyboard.pressed("S")) {
                power /= 1.5;
            }

            //跑車跑很快
            power = Math.clamp(power, 0, 320.0);


            var angle_thrust = angle;
            if (power > 6) {
                if (keyboard.pressed("A"))
                    angle_thrust += 0.7;
                if (keyboard.pressed("D"))
                    angle_thrust -= 0.7;
            }

            // compute force
            var thrust =
                new THREE.Vector3(1, 0, 0).multiplyScalar(power)
                    .applyAxisAngle(new THREE.Vector3(0, 1, 0), angle_thrust);
            force.copy(thrust);
            //阻力
            force.add(vel.clone().multiplyScalar(-2))

            // eulers
            vel.add(force.clone().multiplyScalar(dt));
            pos.add(vel.clone().multiplyScalar(dt));
        }

        function readModel(modelName, objName = 'OBJ', targetSize = 40) {

            var onProgress = function (xhr) {
                if (xhr.lengthComputable) {
                    var percentComplete = xhr.loaded / xhr.total * 100;
                    console.log(Math.round(percentComplete, 2) + '% downloaded');
                }
            };

            var onError = function (xhr) { };

            var mtlLoader = new THREE.MTLLoader();
            mtlLoader.setPath('models/');
            mtlLoader.load(modelName + '.mtl', function (materials) {

                materials.preload();

                var objLoader = new THREE.OBJLoader();
                objLoader.setMaterials(materials);
                objLoader.setPath('models/');
                objLoader.load(modelName + '.obj', function (object) {
                    let theObject = unitize(object, targetSize, "OBJ");
                    // theObject.add(new THREE.BoxHelper(theObject))

                    theObject.name = objName;
                    scene.add(theObject);
                    //不須改變軸的方向
                    // theObject.setRotationFromEuler(new THREE.Euler(3.1416 / 2, 0, -3.1416 / 2, 'ZYX'))

                }, onProgress, onError);

            });

        }
        ////////////////////////////////////////
        // wrap an Object3D around the given object
        // so that it is centered at +Y axis
        // 
        function unitize(object, targetSize, objName) {

            // find bounding box of 'object'
            var box3 = new THREE.Box3();
            box3.setFromObject(object);
            var size = new THREE.Vector3();
            size.subVectors(box3.max, box3.min);
            var center = new THREE.Vector3();
            center.addVectors(box3.max, box3.min).multiplyScalar(0.5);

            console.log('center: ' + center.x + ', ' + center.y + ', ' + center.z);
            console.log('size: ' + size.x + ', ' + size.y + ', ' + size.z);

            // uniform scaling according to objSize
            var objSize = Math.max(size.x, size.y, size.z);
            var scaleSet = targetSize / objSize;

            var theObject = new THREE.Object3D();
            theObject.add(object);
            object.scale.set(scaleSet, scaleSet, scaleSet);
            object.position.set(-center.x * scaleSet, center.y * scaleSet, -center.z * scaleSet);

            object.rotation.y = Math.PI / 2;
            // let axis = new THREE.AxesHelper(10000);
            // theObject.add(axis);
            return theObject;
        }

        function loadCubemap() {

            var path = "textures/cubeMap2/";
            var format = '.png';
            var urls = [
                path + 'posx' + format, path + 'negx' + format,
                path + 'posy' + format, path + 'negy' + format,
                path + 'posz' + format, path + 'negz' + format
            ];
            var loader = new THREE.CubeTextureLoader();
            var cubeMap = loader.load(urls);
            cubeMap.format = THREE.RGBFormat;
            return cubeMap;

        }
    </script>
</body>

</html>