<!DOCTYPE html>
<html>

<head>
    <title>HW6-Filter, Render Target, Normal Map</title>
    <meta charset="utf-8">
    <link rel="stylesheet" href="vendor/css/bootstrap.min.css">
    <link href="style.css" rel="stylesheet">
    <style>
        #canvas {
            margin-left: auto;
            margin-right: auto;
            display: block;
            width: 800px;
            position: absolute;
        }

        #navbar {
            position: absolute;
            width: 100%;
            text-align: center;
            margin: 0 auto;
            color: #ff0000;
            font-size: 15px;
        }

        #loading {
            z-index: 10;
            position: absolute;
            width: 100%;
            height: 100%;
            text-align: center;
            margin: 0 auto;
            color: #ffffff;
            font-size: 40px;
        }
    </style>
</head>

<body>
    <div id="canvas"></div>
    <div id="loading" class="align-middle">loading...</div>
    <div id="navbar" class="align-middle">
        HW 6 Filter, Render Target, Normal Map
        <a class="nav-link" href="index.html">Home</a>
    </div>
    <script src="./vendor/js/jquery-3.3.1.min.js"></script>
    <script src="https://threejs.org/build/three.min.js"></script>
    <script src="https://raw.githack.com/mrdoob/three.js/dev/examples/js/loaders/MTLLoader.js"></script>
    <script src="https://raw.githack.com/mrdoob/three.js/dev/examples/js/loaders/OBJLoader.js"></script>
    <script src="https://threejs.org/examples/js/controls/OrbitControls.js"></script>
    <script src="https://raw.githack.com/mrdoob/three.js/dev/examples/js/geometries/TeapotBufferGeometry.js"></script>
    <!--use computeTangents-->
    <script src="https://raw.githack.com/mrdoob/three.js/master/examples/js/utils/BufferGeometryUtils.js"></script>
    <!--text-->
    <script src="./vendor/js/text2D.js"></script>
    <!--MMD-->
    <!-- <script src="js/libs/ammo.js"></script> -->
    <script src="./vendor/js/MMDParse.js"></script>
    <script src="https://raw.githack.com/mrdoob/three.js/dev/examples/js/loaders/MMDLoader.js"></script>
    <script type="module"
        src="https://raw.githack.com/mrdoob/three.js/dev/examples/jsm/animation/MMDAnimationHelper.js"></script>

    <!--Mosaic-start-->
    <script id="vs-mosaic" type="x-shader/x-vertex">
        varying vec2 vUv; 
        void main() { 
            gl_Position = projectionMatrix* modelViewMatrix * vec4( position, 1.0); 
            vUv = uv; 
        }
    </script>
    <script id="fs-mosaic" type="x-shader/x-fragment">
        uniform sampler2D texture; 
        varying vec2 vUv; 
        uniform float gran;
        vec2 vUvm;
        uniform vec2 headNDC;
        uniform float headSize;
        uniform bool front;

        void main() {
            if(front){
                float d = distance (headNDC, vUv);
                float borderWidth = headSize*0.1; 
                if (d < headSize) {
                    vUvm = floor (vUv/gran)*gran;
                    gl_FragColor = texture2D(texture, vUvm);
                } else if (d < headSize+borderWidth) {
                    //馬賽克外圈的顏色
                    gl_FragColor = vec4(1,0.0784313725,0.576470588,1);
                } else {
                    vUvm = vUv;
                    gl_FragColor = texture2D(texture, vUvm);
                }
            }
            else{
                //如果看不到臉直接把材質貼回去
                gl_FragColor = texture2D(texture, vUv);
            }
        }
    </script>
    <!--Mosaic-end-->

    <!--海報-start-->
    <script id="vs-texSwap" type="x-shader/x-vertex">
        uniform int which; // 0, 1, 2, 3
        varying vec2 vUv; 
        void main() {
           gl_Position = projectionMatrix* modelViewMatrix * vec4( position, 1.0);      
           vUv = vec2 ((uv.s + float(which))/4., uv.t); 
        }
    </script>
    <script id="fs-texSwap" type="x-shader/x-fragment">
        uniform sampler2D texture; 
        varying vec2 vUv; 
        void main() {
            vec3 color = texture2D (texture, vUv).rgb;
            gl_FragColor = vec4 (color, 1.0); 
        }
    </script>

    <script id="vs-sobel" type="x-shader/x-vertex">
        varying vec2 vUv; 
        void main() { 
            gl_Position = projectionMatrix* modelViewMatrix * vec4( position, 1.0); 
            vUv = uv; 
        }
    </script>
    <script id="fs-sobel" type="x-shader/x-fragment">
        uniform sampler2D texture; 
        uniform vec2 imageSize;
        varying vec2 vUv; 
        float step_w = 1.0/imageSize.x; 
        float step_h = 1.0/imageSize.y; 
        void main() { 
            float kernel[9];
                
            vec2 offset[9]; 
            offset[0]=vec2(-step_w, -step_h); 
            offset[1]=vec2(0.0, -step_h); offset[2]= vec2(step_w, -step_h), 
            offset[3]=vec2(-step_w, 0.0), offset[4]=vec2(0.0, 0.0), offset[5]=vec2(step_w, 0.0), 
            offset[6]=vec2(-step_w, step_h), offset[7]=vec2(0.0, step_h), offset[8]=vec2(step_w, step_h); 
            
            // sobel filter - Gx
            for (int i = 0; i < 9; i++) kernel[i]=0.0; 
            kernel[0] = -1.0; kernel[2] = 1.0;
            kernel[3] = -2.0; kernel[5] =  2.0;
            kernel[6] = -1.0; kernel[8] = 1.0;
        
            vec3 sumX= vec3(0.0); 
            for (int i=0 ; i < 9; i++) { 
                vec3 tmp=texture2D (texture, vUv+offset[i]).rgb; 
                sumX += tmp*kernel[i]; 
            }
            
            // sobel filter - Gy
            for (int i = 0; i < 9; i++) kernel[i]=0.0; 
            kernel[6] = -1.0; kernel[7] = -2.0; kernel[8] = -1.0;
            kernel[0] = 1.0; kernel[1] = 2.0; kernel[2] = 1.0;
        
            vec3 sumY= vec3(0.0); 
            for (int i=0 ; i < 9; i++) { 
                vec3 tmp=texture2D (texture, vUv+offset[i]).rgb; 
                sumY += tmp*kernel[i]; 
            }
            vec3 delX = vec3 (1, 0, sumX);
            vec3 delY = vec3 (0, 1, sumY);
            vec3 n = normalize (cross (delX, delY));
            
            vec3 encode = (n + vec3 (1))/2.0;
            
            gl_FragColor = vec4 (encode, 1.0); 
        }
    </script>

    <script id="vs-normalmap" type="x-shader/x-vertex">
        uniform vec3 lightpos;

        attribute vec4 tangent;
        varying vec2 vUv;
        varying vec3 vTangent;
        varying vec3 vBitangent;
        varying vec3 vNormal;
        varying vec3 vLL;

        void main() {
            vec4 vWorldpos = modelMatrix * vec4( position, 1.0 ) ;
            vec2 myrepeat = vec2 (1.0, 1.0);
            vUv = myrepeat*uv;

            gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );

            // TBN in eyespace 
            // no need to normalize these varying variable
            // as they will be normalized in fragment shader
            //
            vNormal = normalMatrix * normal ;
            vTangent = normalMatrix * tangent.xyz ;
            vBitangent = cross( vNormal, vTangent ) ;

            vLL = normalMatrix * (lightpos - vWorldpos.xyz);
        }
    </script>
    <script id='fs-normalmap' type="x-shader/x-vertex">
        uniform sampler2D tNormal;
        varying vec2 vUv;
        varying vec3 vTangent;
        varying vec3 vBitangent;
        varying vec3 vNormal;
        varying vec3 vLL;

        void main() {
            vec3 normalTex = texture2D (tNormal, vUv).xyz * 2.0 - 1.0;
            normalTex.xy *= 6.0;    // exaggerate the normal deviation
            normalTex = normalize( normalTex );

            mat3 tsb = mat3( normalize( vTangent ), normalize( vBitangent ), normalize( vNormal ) );
            vec3 finalNormal = tsb * normalTex;
            float ndotl = dot (normalize (vLL), normalize (finalNormal));
            gl_FragColor = vec4( vec3(ndotl), 1 );
        }
    </script>
    <!--海報-end-->

    <!--灰階場景-start-->
    <script id="mono-vs" type="x-shader/x-vertex">
        varying vec2 vUv;
        void main(){
            gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
            vUv = uv;
        }
    </script>
    <script id="mono-fs" type="x-shader/x-fragment">
        uniform sampler2D texture;
        uniform vec2 imageSize;
        varying vec2 vUv;

        vec3 rgb2hsv(vec3 c) {
            vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);
            vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));
            vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));

            float d = q.x - min(q.w, q.y);
            float e = 1.0e-10;
            return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);
        }

        vec3 hsv2rgb(vec3 c) {
            vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);
            vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);
            return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);
        }
          
        void main() { 
            vec3 color = texture2D (texture, vUv).rgb;
            vec3 hh = rgb2hsv (color);
            hh.y = 0.0;
            vec3 cc = hsv2rgb (hh);
            gl_FragColor = vec4 (cc, 1.0); 
        }
    </script>
    <!-- shader for eyeNormal Plot -->
    <script id="vsNormal" type="x-shader/x-vertex">
        varying vec3 vNormal;
        void main() { 
            gl_Position = projectionMatrix* modelViewMatrix * vec4( position, 1.0); 
            vNormal = normalMatrix*normal;
        }
    </script>
    <script id="fsNormal" type="x-shader/x-fragment">
        varying vec3 vNormal; // [-1,1]^3
        void main() {    
            vec3 color = (normalize(vNormal)+1.0)/2.; // [0,1]^3
            gl_FragColor = vec4 (color,1);
        }
    </script>
    <!--灰階場景-end-->

    <!--teapotShader-start-->
    <!-- shader for Lapace filter -->
    <!-- with background discard  -->
    <script id="vsFilter" type="x-shader/x-vertex">
        varying vec2 vUv; 
        void main() { 
            gl_Position = projectionMatrix* modelViewMatrix * vec4( position, 1.0); 
            vUv = uv; 
        }
    </script>
    <script id="fsFilter" type="x-shader/x-fragment">
        uniform sampler2D texture; 
        uniform int imageSize;
        varying vec2 vUv; 
        void main() { 
            float step_w = 1.0/float(imageSize);
            float step_h = 1.0/float(imageSize);
            // Laplace filter
            float kernel[9]; 
            kernel[0] = kernel[2] = kernel[6] = kernel[8] = 0.0/1.0; 
            kernel[1] = kernel[3] = kernel[5] = kernel[7] = 1.0/1.0; 
            kernel[4] = -4.0/1.0; 
            vec2 offset[9]; 
            offset[0]=vec2(-step_w, -step_h); 
            offset[1]=vec2(0.0, -step_h); offset[2]= vec2(step_w, -step_h), 
            offset[3]=vec2(-step_w, 0.0), offset[4]=vec2(0.0, 0.0), offset[5]=vec2(step_w, 0.0), 
            offset[6]=vec2(-step_w, step_h), offset[7]=vec2(0.0, step_h), offset[8]=vec2(step_w, step_h); 

            vec3 sum= vec3(0.0); 
            for (int i=0 ; i < 9; i++) { 
                vec3 tmp=texture2D (texture, vUv+offset[i]).rgb; 
                sum += tmp*kernel[i]; 
            }

            if ((sum.r+sum.g+sum.b)/3.0 < 0.1) // if close to (0,0,0)
                discard;
            else 
                gl_FragColor = vec4 (0,0,0, 1.0); 
        }
    </script>

    <!-- shader to cutout "background" -->
    <script id="vsCut" type="x-shader/x-vertex">
        varying vec2 vUv; 
        void main() { 
            gl_Position = projectionMatrix* modelViewMatrix * vec4( position, 1.0); 
            vUv = uv; 
        }
    </script>
    <script id="fsCut" type="x-shader/x-vertex">
        uniform sampler2D texture; 
        varying vec2 vUv;
        void main() {
            vec3 color = texture2D (texture, vUv).rgb;
            if (color.r <= 0.05 && color.g >= 0.95 && color.b <= 0.05)  // close to (0,1,0)
            discard;
            else
            gl_FragColor = vec4 (color, 1);
        }
    </script>
    <script id="toonVertexShader" type="x-shader/x-vertex">
        uniform vec3 lightpos;
        varying float ndotl;
        varying vec3 lightdir;
        varying vec3 eyenorm;
        varying vec2 vUv;
      
        void main() {
            gl_Position = projectionMatrix* modelViewMatrix * vec4( position, 1.0);
            vUv = uv;
            //vec4 worldpos = modelMatrix * vec4 (position, 1.0);
            //ndotl = dot (normalize(lightpos.xyz - worldpos.xyz), normal);
            vec4 eyepos = modelViewMatrix * vec4 (position, 1.0);
            vec4 lighteye = viewMatrix * vec4 (lightpos, 1.0);
            lightdir = lighteye.xyz - eyepos.xyz;
            eyenorm = normalMatrix * normal;
        }
    </script>
    <script id="toonFragmentShader" type="x-shader/x-fragment">
        varying float ndotl;
        varying vec3 lightdir;
        varying vec3 eyenorm;
        uniform sampler2D mytex;
        varying vec2 vUv;
        uniform vec3 uniColor;

        void main() {
            float nn = dot (normalize(lightdir), normalize(eyenorm));
            if (nn > 0.8) {
                nn= 1.0;
            } else if (nn > 0.6) {
                nn = 0.6;
            } else {
                nn = 0.2;
            }

            // vec4 texColor = texture2D (mytex, vUv);
            // gl_FragColor = nn*texColor;

            gl_FragColor = vec4 (nn *uniColor, 1.0);
        }
    </script>
    <!--teapotShader-end-->

    <!--perlin-shader-->
    <script id='perlin-vs' type="x-shader/x-vertex">
        varying vec4 wPos;
        varying vec2 vUv;
        uniform vec2 scale;
        uniform vec2 offset;
    
        void main() {
            vUv = uv * scale + offset;
            wPos = modelMatrix * vec4(position, 1.0);
            gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
        }
    </script>
    <script id='perlin-fs' type="x-shader/x-vertex">
        //
        // FROM: http://jsfiddle.net/jmchen/cby3d1ag/
        //
        vec3 mod289(vec3 x) {
            return x - floor(x * (1.0 / 289.0)) * 289.0;
        }
    
        vec4 mod289(vec4 x) {
            return x - floor(x * (1.0 / 289.0)) * 289.0;
        }
    
        vec4 permute(vec4 x) {
            return mod289(((x * 34.0) + 1.0) * x);
        }
    
        vec4 taylorInvSqrt(vec4 r) {
            return 1.79284291400159 - 0.85373472095314 * r;
        }
    
        float snoise(vec3 v) {
            const vec2 C = vec2(1.0 / 6.0, 1.0 / 3.0);
            const vec4 D = vec4(0.0, 0.5, 1.0, 2.0);
    
            // First corner
            vec3 i = floor(v + dot(v, C.yyy));
            vec3 x0 = v - i + dot(i, C.xxx);
    
            // Other corners
            vec3 g = step(x0.yzx, x0.xyz);
            vec3 l = 1.0 - g;
            vec3 i1 = min(g.xyz, l.zxy);
            vec3 i2 = max(g.xyz, l.zxy);
    
            //   x0 = x0 - 0.0 + 0.0 * C.xxx;
            //   x1 = x0 - i1  + 1.0 * C.xxx;
            //   x2 = x0 - i2  + 2.0 * C.xxx;
            //   x3 = x0 - 1.0 + 3.0 * C.xxx;
            vec3 x1 = x0 - i1 + C.xxx;
            vec3 x2 = x0 - i2 + C.yyy; // 2.0*C.x = 1/3 = C.y
            vec3 x3 = x0 - D.yyy; // -1.0+3.0*C.x = -0.5 = -D.y
    
            // Permutations
            i = mod289(i);
            vec4 p = permute(permute(permute(
            i.z + vec4(0.0, i1.z, i2.z, 1.0)) + i.y + vec4(0.0, i1.y, i2.y, 1.0)) + i.x + vec4(0.0, i1.x, i2.x, 1.0));
    
            // Gradients: 7x7 points over a square, mapped onto an octahedron.
            // The ring size 17*17 = 289 is close to a multiple of 49 (49*6 = 294)
            float n_ = 0.142857142857; // 1.0/7.0
            vec3 ns = n_ * D.wyz - D.xzx;
    
            vec4 j = p - 49.0 * floor(p * ns.z * ns.z); //  mod(p,7*7)
    
            vec4 x_ = floor(j * ns.z);
            vec4 y_ = floor(j - 7.0 * x_); // mod(j,N)
    
            vec4 x = x_ * ns.x + ns.yyyy;
            vec4 y = y_ * ns.x + ns.yyyy;
            vec4 h = 1.0 - abs(x) - abs(y);
    
            vec4 b0 = vec4(x.xy, y.xy);
            vec4 b1 = vec4(x.zw, y.zw);
    
            //vec4 s0 = vec4(lessThan(b0,0.0))*2.0 - 1.0;
            //vec4 s1 = vec4(lessThan(b1,0.0))*2.0 - 1.0;
            vec4 s0 = floor(b0) * 2.0 + 1.0;
            vec4 s1 = floor(b1) * 2.0 + 1.0;
            vec4 sh = -step(h, vec4(0.0));
    
            vec4 a0 = b0.xzyw + s0.xzyw * sh.xxyy;
            vec4 a1 = b1.xzyw + s1.xzyw * sh.zzww;
    
            vec3 p0 = vec3(a0.xy, h.x);
            vec3 p1 = vec3(a0.zw, h.y);
            vec3 p2 = vec3(a1.xy, h.z);
            vec3 p3 = vec3(a1.zw, h.w);
    
            //Normalise gradients
            vec4 norm = taylorInvSqrt(vec4(dot(p0, p0), dot(p1, p1), dot(p2, p2), dot(p3, p3)));
            p0 *= norm.x;
            p1 *= norm.y;
            p2 *= norm.z;
            p3 *= norm.w;
    
            // Mix final noise value
            vec4 m = max(0.6 - vec4(dot(x0, x0), dot(x1, x1), dot(x2, x2), dot(x3, x3)), 0.0);
            m = m * m;
            return 42.0 * dot(m * m, vec4(dot(p0, x0), dot(p1, x1),
            dot(p2, x2), dot(p3, x3)));
        }
    
        uniform int terms;
        uniform int use2D;
        uniform float time;
        varying vec2 vUv;
        varying vec4 wPos;
        
        //取得alphaMap
        uniform sampler2D mask;

        float surface3(vec3 coord) {
            float height = 0.0;
            height += abs(snoise(coord)) * 1.0;
            if (terms >= 2)    
                height += abs(snoise(coord * 2.0)) * 0.5;
            if (terms >= 3)
                height += abs(snoise(coord * 4.0)) * 0.25;
            if (terms >= 4)
                height += abs(snoise(coord * 8.0)) * 0.125;
            // can add more terms ...
            if (terms >= 5)   
                 height += abs(snoise(coord * 16.0)) * 0.0625;
            return height;
        }
    
        void main() {
            float scale = 1.0;
            vec3 coord = vec3(scale * vUv[0], scale * vUv[1], time);
            float height = surface3(coord);
    
            float r;
            r = height;

            //找透明區塊
            vec4 texColor = texture2D (mask, vUv);
            if(texColor.a < 0.5){
                gl_FragColor = vec4(r*0.3, r*0.4, r*0.5, 1.0) * 1.2;
            }else{
                gl_FragColor = vec4(r*0.97, r*0.9, r*0.87, 0.5) * 1.2;
            }
        }
    </script>
    <!--perlin-shader-->
    <script type='module'>
        //debug used, don't load model
        var debug = false;
        $("#navbar").hide();
        //檢查FPS
        javascript: (function () { var script = document.createElement('script'); script.onload = function () { var stats = new Stats(); document.body.appendChild(stats.dom); requestAnimationFrame(function loop() { stats.update(); requestAnimationFrame(loop) }); }; script.src = 'https://mrdoob.github.io/stats.js/build/stats.min.js'; document.head.appendChild(script); })();
        import { readModel } from './vendor/js/vendor.js';
        import { loadMiku, createDesk, createPenBox, createWall, buildModel, miku, mikuPoseHelper, mikuObj } from './vendor/js/hw6.js';
        //必要全域變數
        //場景有三個，灰色的、影像處理的與彩色的
        var sceneGrey, scene0, sceneColor;
        //攝影機有兩台，一台照實際場景，另一台只照上了tenderTarget的板子
        var camera, camera0, renderer;

        //茶壺用
        var teapot, teapotClone, planeXX;
        //1
        var scene1, camera1;
        //RTT
        var sceneRTT, cameraRTT, material_shh, renderTarget1;
        //regular
        var sceneRegular, renderTarget_whole;

        //海報用
        var shaderMaterialNormal;
        var texSwapRenderTarget, sceneTexSwap, cameraTexSwap, which = 0;
        var sceneSobel, sobelRenderTarget, cameraSobel;
        var fWidth = 150, fHeight = 170;
        //point light
        var pLight, pAngle = 0, r = 1;

        //miku
        var renderTargetMosaic, sceneMosaic, materialMosaic, cameraMosaic;

        //招牌
        var sign, clock;

        //歐逼康輟
        var controls;
        //拿去上材質用
        var renderTarget;
        //視窗大小
        var width = window.innerWidth;// * 0.9;
        var height = window.innerHeight;// * 0.9;
        //檢查load狀態
        var loadFinish = false;
        var objNameList = [];
        var teapot;

        init();
        animate();

        function init() {
            sceneGrey = new THREE.Scene();
            $("#canvas").width(width);
            $("#canvas").height(height);
            renderer = new THREE.WebGLRenderer();
            //不自動清除畫面
            renderer.autoClear = false;
            renderer.setSize(width, height);
            renderer.setClearColor('black');
            //陰影
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = 2;
            $('#canvas').append(renderer.domElement);
            camera = new THREE.PerspectiveCamera(
                80,
                width / height,
                1,
                1000
            );
            camera.position.set(0, 115, -70);
            window.camera = camera;
            ////////////////////////////////////////////////////////////////////////
            sceneTexSwapInit();
            sceneSobelInit();
            paintingInit();
            ////////////////////////////////////////////////////////////////////////

            scene1Init();
            sceneRTTInit();
            sceneRegularInit();

            sceneGreyInit();
            scene0Init();
            seneColorInit();

            sceneMosaicInit();
            //歐逼康啜
            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.name = 'controls';
            // 禁用方向鍵調整歐逼康輟位置
            controls.enableKeys = false;

            window.addEventListener('resize', (function onWindowResize() {
                width = window.innerWidth;
                height = window.innerHeight;
                camera.aspect = width / height;
                camera.updateProjectionMatrix();
            }), false);
        }

        function sceneTexSwapInit() {
            texSwapRenderTarget = new THREE.WebGLRenderTarget(fWidth, fHeight);
            sceneTexSwap = new THREE.Scene();
            //照比例顯示圖片的大小
            cameraTexSwap = new THREE.OrthographicCamera(fWidth / -2, fWidth / 2, fHeight / 2, fHeight / -2, -10, 100);
            var uniforms = {
                texture: {
                    type: 't',
                    value: null
                },
                which: {
                    type: 'i',
                    value: 0
                }
            };

            var vertShader = document.getElementById('vs-texSwap').textContent;
            var fragShader = document.getElementById('fs-texSwap').textContent;
            var shaderMaterial = new THREE.ShaderMaterial({
                uniforms: uniforms,
                vertexShader: vertShader,
                fragmentShader: fragShader
            });
            // to get texture image size:
            // https://stackoverflow.com/questions/49111431/how-to-get-texture-dimensions-with-three-js

            let loader = new THREE.TextureLoader();
            loader.crossOrigin = '';
            let myface = './vendor/textures/myface.png';
            let texture = loader.load(myface, function (tex) {
                texture.wrapS = THREE.RepeatWrapping;
                console.log(tex.image.width + ', ' + tex.image.height);
                shaderMaterial.uniforms.texture.value = tex;
            });

            let plane = new THREE.Mesh(new THREE.PlaneGeometry(150, 170), shaderMaterial);
            sceneTexSwap.add(plane);

            function incWhich() {
                which += 1;
                shaderMaterial.uniforms.which.value = which;
                setTimeout(incWhich, 500);
            }
            setTimeout(incWhich, 0);
        }

        function sceneSobelInit() {
            sceneSobel = new THREE.Scene();
            //照比例顯示圖片的大小
            cameraSobel = new THREE.OrthographicCamera(fWidth / -2, fWidth / 2, fHeight / 2, fHeight / -2, -10, 100);

            var uniforms = {
                imageSize: {
                    type: 'v2',
                    value: new THREE.Vector2(256, 256)
                },
                texture: {
                    type: 't',
                    value: texSwapRenderTarget.texture
                },
            };

            var vertShader = document.getElementById('vs-sobel').textContent;
            var fragShader = document.getElementById('fs-sobel').textContent;
            let material_shader = new THREE.ShaderMaterial({
                uniforms: uniforms,
                vertexShader: vertShader,
                fragmentShader: fragShader,
                side: THREE.DoubleSide
            });

            var geometry = new THREE.PlaneGeometry(fWidth, fHeight);
            var mesh = new THREE.Mesh(geometry, material_shader);
            sceneSobel.add(mesh)
            sobelRenderTarget = new THREE.WebGLRenderTarget(fWidth, fHeight);
        }

        function sceneGreyInit() {
            //讓海報有光源做變化
            pLight = new THREE.PointLight(0xffffff, 0.8, 100);
            sceneGrey.add(pLight);
            var pointLightHelper = new THREE.PointLightHelper(pLight, 1);
            sceneGrey.add(pointLightHelper);
            //環境光源
            let aLight = new THREE.AmbientLight(0xffffff, 0.8);
            sceneGrey.add(aLight);

            //純喫茶
            let tryittea = buildModel();
            tryittea.castShadow = true;
            tryittea.receiveShadow = true;
            tryittea.position.set(-115, 41, 65);
            tryittea.rotation.y = -Math.PI / 6;
            sceneGrey.add(tryittea);
            if (!debug) {
                //讀取 MacBookPro
                readModel("mpm_f21__Apple_MacBook_Pro_15", 'MacBookPro', 30, sceneGrey);
                objNameList.push('MacBookPro');

                //讀取椅子
                readModel("Chair", 'Chair', 55, sceneGrey);
                objNameList.push('Chair');

                //讀取床
                readModel("bed", 'bed', 110, sceneGrey, 'Y');
                objNameList.push('bed');

                /////////////////////////////////////////////

                //讀取檯燈
                readModel("Lamp", 'lamp', 30, sceneGrey, 'Z');
                objNameList.push('lamp');

                /////////////////////////////////////////////

                //讀取吊燈
                readModel("Brass_Freak", 'ceilLamp', 60, sceneGrey);
                objNameList.push('ceilLamp');
            }

            let dLight = new THREE.DirectionalLight(0xffffff, 0.5);
            dLight.position.set(0, 100, 0);
            dLight.castShadow = true;
            dLight.shadow.camera.left = -280;
            dLight.shadow.camera.top = -260;
            dLight.shadow.camera.right = 280;
            dLight.shadow.camera.bottom = 200;
            dLight.shadow.camera.near = 1;
            dLight.shadow.camera.far = 400;
            dLight.target = sceneGrey;
            dLight.shadow.mapSize.width = dLight.shadow.mapSize.height = 1024;
            dLight.shadow.bias = -.01;
            sceneGrey.add(dLight);

            //地板
            //https://www.3dxo.com/textures/4961_wood_8
            let planeMat = new THREE.TextureLoader().load('vendor/textures/wood.jpg');
            planeMat.wrapS = THREE.RepeatWrapping;
            planeMat.wrapT = THREE.RepeatWrapping;
            planeMat.repeat.set(15, 12);
            let plane = new THREE.Mesh(new THREE.PlaneGeometry(250, 200, 4, 4),
                new THREE.MeshLambertMaterial({
                    side: THREE.DoubleSide, // 雙面材質
                    map: planeMat,
                    color: 0xF0F0F0,
                }));
            plane.rotation.x -= Math.PI / 2;
            //地板可以出現影子
            plane.receiveShadow = true;
            sceneGrey.add(plane);
            //牆壁
            let walls = [
                createWall(true, 250),
                createWall(true, 250),
                createWall(false, 200),
                createWall(false, 200)
            ];
            walls[0].position.z = 101;
            walls[1].position.z = -101;
            walls[2].position.x = 126;
            walls[3].position.x = -126;
            walls.forEach(function (wall) {
                wall.receiveShadow = true;
                sceneGrey.add(wall);
            });
            //桌子
            let desk = createDesk();
            desk.position.set(-85, 0, 70);
            sceneGrey.add(desk);
            //天花板
            let ceiling = new THREE.Mesh(
                new THREE.BoxGeometry(250, 2, 200),
                new THREE.MeshLambertMaterial({
                    color: 'beige'
                })
            );
            ceiling.position.y = 201;
            sceneGrey.add(ceiling);

            //筆筒
            let penBox = new THREE.Object3D();
            // let pens = [new THREE.Object3D(), new THREE.Object3D()];
            readModel('Pen', 'pen', 10, penBox);
            readModel('Pen', 'pen1', 10, penBox, undefined, 'Pen1');
            objNameList.push('pen', 'pen1');
            let box = createPenBox();
            penBox.add(box);

            penBox.position.set(-110, 41, 85);
            sceneGrey.add(penBox);
        }

        function scene0Init() {
            scene0 = new THREE.Scene();

            //左 右 上 下 near far
            camera0 = new THREE.OrthographicCamera(0, width, height, 0, -10, 100);
            // full-size RT
            renderTarget = new THREE.WebGLRenderTarget(width, height);
            let greyPlane = new THREE.Mesh(
                new THREE.PlaneGeometry(width, height),
                new THREE.ShaderMaterial({
                    uniforms: {
                        imageSize: {
                            type: 'v2',
                            value: new THREE.Vector2(width, height)
                        },
                        texture: {
                            type: 't',
                            value: renderTarget.texture
                        }
                    },
                    vertexShader: document.getElementById('mono-vs').textContent,
                    fragmentShader: document.getElementById('mono-fs').textContent,
                    depthTest: false,  // no depth test
                    depthWrite: false  // do not write depth buffer
                })
            );
            greyPlane.position.set(width / 2, height / 2, 0);
            scene0.add(greyPlane);
        }

        function seneColorInit() {
            sceneColor = new THREE.Scene();
            let alight = new THREE.AmbientLight(0xffffff);
            sceneColor.add(alight);
            let cutoutShaderMat = new THREE.ShaderMaterial({
                uniforms: {
                    texture: { type: 't', value: renderTarget_whole.texture }
                },
                vertexShader: document.getElementById('vsCut').textContent,
                fragmentShader: document.getElementById('fsCut').textContent
            });
            //虛擬房間的招牌
            //茶壺
            planeXX = new THREE.Mesh(new THREE.PlaneGeometry(50, 50), cutoutShaderMat);
            planeXX.position.set(-60, 47, 60);
            sceneColor.add(planeXX);
            loadMiku(sceneColor);
            //招牌相關
            clock = new THREE.Clock();
            createSign();
        }

        function scene1Init() {
            var material_shh_normal = new THREE.ShaderMaterial({
                vertexShader: document.getElementById('vsNormal').textContent,
                fragmentShader: document.getElementById('fsNormal').textContent
            });

            // scene1: contains a torusKnot with shaderMaterial (for outline)
            // camera1: ortho camera

            scene1 = new THREE.Scene();
            teapot = new THREE.Mesh(new THREE.TeapotBufferGeometry(5),
                material_shh_normal);
            scene1.add(teapot);
            camera1 = new THREE.OrthographicCamera(-20, 20, 20, -20, -200, 200);
        }

        function sceneRTTInit() {
            renderTarget1 = new THREE.WebGLRenderTarget(512, 512);

            var uniforms = {
                imageSize: {
                    type: 'i',
                    value: renderTarget1.width
                },
                texture: {
                    type: 't',
                    value: renderTarget1.texture
                }
            };

            material_shh = new THREE.ShaderMaterial({
                uniforms: uniforms,
                vertexShader: document.getElementById('vsFilter').textContent,
                fragmentShader: document.getElementById('fsFilter').textContent
            });

            // sceneRTT: 用plane做外框
            sceneRTT = new THREE.Scene();
            cameraRTT = new THREE.OrthographicCamera(-50, 50, 50, -50, -10, 10);
            var bs = new THREE.Mesh(new THREE.PlaneGeometry(100, 100), material_shh);
            sceneRTT.add(bs);
        }

        function sceneRegularInit() {
            // 這裡放我要的彩色茶壺
            sceneRegular = new THREE.Scene();
            var geometry = new THREE.TeapotBufferGeometry(5);
            var material = new THREE.ShaderMaterial({
                uniforms: {
                    lightpos: { type: 'v3', value: new THREE.Vector3() },
                    shading: { type: 'i', value: 1 },
                    coordinate: { type: 'i', value: 0 },
                    uniColor: { type: 'v3', value: new THREE.Vector3(161, 37, 13).multiplyScalar(1 / 255) }
                },
                vertexShader: document.getElementById('toonVertexShader').textContent,
                fragmentShader: document.getElementById('toonFragmentShader').textContent,
            });
            teapotClone = teapot.clone();
            teapotClone.material = material;
            sceneRegular.add(teapotClone);

            teapotClone.material.uniforms.lightpos.value.set(-60, 100, 60);
            //////////////////////
            renderTarget_whole = new THREE.WebGLRenderTarget(512, 512);
        }

        function paintingInit() {
            //顯示在房間中的圖片大小，用15比17去算倍率
            var geometry = new THREE.PlaneBufferGeometry(30, 34);
            THREE.BufferGeometryUtils.computeTangents(geometry);

            var uniforms = {
                imageSize: {
                    type: 'v2',
                    value: 512
                },
                tNormal: {
                    type: 't',
                    value: sobelRenderTarget.texture
                },
                lightpos: {
                    type: 'v3',
                    value: new THREE.Vector3()
                }

            };

            var vertShader = document.getElementById('vs-normalmap').textContent;
            var fragShader = document.getElementById('fs-normalmap').textContent;

            shaderMaterialNormal = new THREE.ShaderMaterial({
                uniforms: uniforms,
                vertexShader: vertShader,
                fragmentShader: fragShader
            });
            let mesh = new THREE.Mesh(geometry, shaderMaterialNormal);
            sceneGrey.add(mesh);
            //貼牆的話是125，會切到所以往前拉
            mesh.position.set(-123, 60, -10);
            mesh.rotation.y = Math.PI / 2;
        }

        function sceneMosaicInit() {
            sceneMosaic = new THREE.Scene();
            renderTargetMosaic = new THREE.WebGLRenderTarget(width, height);//256,256); 
            var uniforms = {
                headNDC: {
                    type: 'v2',
                    value: null
                },
                headSize: {
                    type: 'f',
                    value: 0
                },
                texture: {
                    type: 't',
                    value: renderTargetMosaic.texture
                },
                gran: {
                    type: 'f',
                    value: 0
                },
                front: {
                    type: 'b',
                    value: false
                }
            };

            var vertShader = document.getElementById('vs-mosaic').innerHTML;
            var fragShader = document.getElementById('fs-mosaic').innerHTML;
            materialMosaic = new THREE.ShaderMaterial({
                uniforms: uniforms,
                vertexShader: vertShader,
                fragmentShader: fragShader
            });
            //設為跟螢幕一樣大
            let mosaicPlane = new THREE.Mesh(new THREE.PlaneGeometry(width, height), materialMosaic);
            //照mosaicPlane的
            cameraMosaic = new THREE.OrthographicCamera(-width / 2, width / 2, height / 2, -height / 2, -500, 1000);
            sceneMosaic.add(mosaicPlane);
        }

        function animate() {
            if (!loadFinish) {
                let isOK = true;
                objNameList.forEach(function (name) {
                    if (sceneGrey.getObjectByName(name) === undefined) {
                        isOK = false;
                    }
                });
                //如果miku也沒有load進來
                if (mikuObj === undefined) isOK = false;
                if (isOK) {
                    //loading結束
                    document.getElementById("loading").style.display = "none";
                    $("#navbar").show();
                    ///////////////////////////////////
                    //如果debug模式不用管位置
                    if (!debug) initPosition();
                    //初始化完畢
                    loadFinish = !loadFinish;
                    window.miku = miku;
                }
            } else {
                var delta = clock.getDelta();
                // window.sign = sign
                if (delta != 0)
                    sign.material.uniforms.time.value += delta / 15;
                headCompute();
                render();
            }
            requestAnimationFrame(animate);
            if (Math.abs(pAngle) > Math.PI / 2) r = -r;
            pAngle += 0.01 * r;
            let v3 = new THREE.Vector3(-123 + Math.cos(pAngle) * 20, 60, -10 + Math.sin(pAngle) * 20);
            pLight.position.copy(v3);
            shaderMaterialNormal.uniforms.lightpos.value.copy(v3);
        }

        function initPosition() {
            let MacBookPro = sceneGrey.getObjectByName('MacBookPro');
            MacBookPro.position.set(-90, 41, 60);
            MacBookPro.rotation.y = Math.PI / 2;
            let pen = sceneGrey.getObjectByName('pen');
            pen.position.set(0.5, 3, -0.5);
            pen.rotation.x = Math.PI / 7.5;
            let pen1 = sceneGrey.getObjectByName('pen1');
            pen1.position.set(-1.7, 3, 0.6);
            pen1.rotation.y = Math.PI * 3 / 2;
            pen1.rotation.z = Math.PI / 3.5
            let ceilLamp = sceneGrey.getObjectByName('ceilLamp');
            ceilLamp.position.y = 200;
            let deskLamp = sceneGrey.getObjectByName('lamp');
            deskLamp.position.set(-50, 41, 80);
            deskLamp.rotation.y = Math.PI * 3 / 4;
            let chair = sceneGrey.getObjectByName('Chair');
            chair.position.set(-90, 0, 40);
            chair.rotation.y = -Math.PI / 2;
            let bed = sceneGrey.getObjectByName('bed');
            bed.position.set(135, -0.5, 110.5);
            bed.rotation.y = Math.PI / 2;
        }

        function render() {
            paintingRender();
            //換去渲染plane的tex
            renderer.setRenderTarget(renderTarget);
            renderer.clear();
            //這次要上色，要讓板子能夠有畫面出來
            sceneGrey.traverse(function (obj) {
                if (obj instanceof THREE.Mesh) {
                    if (obj.material instanceof Array) {
                        obj.material.forEach(function (mat) {
                            mat.colorWrite = true;
                        });
                    } else {
                        obj.material.colorWrite = true;
                    }
                }
            });

            renderer.render(sceneGrey, camera);


            material_shh.uniforms.imageSize.value = 128;
            // this value can alter the width of silhouette !!
            // 1024: original width
            // 512, 256, 128, ...: wider silhouette

            // scene0: torusKnot with shaderMaterial (draw eyeNormal)
            renderer.setRenderTarget(renderTarget1);
            renderer.setClearColor(0x000000);
            renderer.render(scene1, camera1);  // produce eyeNormal plot of subject

            // sceneRTT: fullQuad + filter (discard "near black" fragments)
            renderer.setRenderTarget(renderTarget_whole);
            renderer.setClearColor(0x00ff00);  // yellow "magic" background ... to be cutout
            renderer.render(sceneRTT, cameraRTT);  // produce outline

            // overlay the lit torusKnot
            renderer.render(sceneRegular, camera1); // camera0: the same as eyeNormal plot

            ///////// final texture completed (except boundary removal)
            let pz = new THREE.Vector3(0, 0, 1);
            let py = new THREE.Vector3(0, 1, 0);
            let point = camera.position.clone().sub(planeXX.position).projectOnPlane(py);
            let angle = point.angleTo(pz);
            let test = new THREE.Vector3().crossVectors(pz, point);
            if (test.y > 0) {
                angle = -angle;
            }
            teapot.rotation.y = angle;
            teapotClone.rotation.y = angle;
            planeXX.lookAt(camera.position.x, 47, camera.position.z);

            //從渲染螢幕改為渲染成要處理馬賽克的RT
            renderer.setRenderTarget(renderTargetMosaic);
            //渲染板子出來
            renderer.render(scene0, camera0);

            //這次渲染只做depth test(只看z-buffer)
            sceneGrey.traverse(function (obj) {
                if (obj instanceof THREE.Mesh) {
                    if (obj.material instanceof Array) {
                        obj.material.forEach(function (mat) {
                            mat.colorWrite = false;
                        });
                    } else {
                        obj.material.colorWrite = false;
                    }
                }
            });
            renderer.render(sceneGrey, camera);

            renderer.render(sceneColor, camera);
            //再來去渲染螢幕
            renderer.setRenderTarget(null);
            renderer.render(sceneMosaic, cameraMosaic);

            //要清空原本的
            renderer.setRenderTarget(renderTarget1);
            renderer.clear();
            renderer.setRenderTarget(renderTarget_whole);
            renderer.clear();
            renderer.setRenderTarget(renderTargetMosaic);
            renderer.clear();
        }

        function paintingRender() {
            renderer.setRenderTarget(texSwapRenderTarget);
            renderer.render(sceneTexSwap, cameraTexSwap);
            renderer.setRenderTarget(sobelRenderTarget);
            renderer.render(sceneSobel, cameraSobel);
        }

        function headCompute() {
            // compute headNDC
            //人頭正中心
            var headCenter = new THREE.Vector3(6, 68, 18.3);
            miku.localToWorld(headCenter);
            //頭頂，設一個高處
            var headTop = new THREE.Vector3(6, 70, 18.3);
            miku.localToWorld(headTop);
            //找到鼻子在物件中的位置
            //我原本找10.5,67.3,17.3
            //可是人頭比較往下看，所以要在往更前面找
            var noseTip = new THREE.Vector3(10.5, 68, 17.3);
            miku.localToWorld(noseTip);

            //找到頭中心點、鼻子和頭頂的gl_position
            headCenter.applyMatrix4(camera.matrixWorldInverse).applyMatrix4(camera.projectionMatrix);
            //頭的標準化設備座標(x,y)
            //要+1/2是因為NDC是從0~1，而headCenter原本是-1~1
            materialMosaic.uniforms.headNDC.value = new THREE.Vector2((headCenter.x + 1) / 2, (headCenter.y + 1) / 2);
            noseTip.applyMatrix4(camera.matrixWorldInverse).applyMatrix4(camera.projectionMatrix);
            headTop.applyMatrix4(camera.matrixWorldInverse).applyMatrix4(camera.projectionMatrix);
            //往正z方向是越靠前，所以鼻子的z比頭中心的z近，則是看的到臉惹
            //上面這句話跟我的code有衝突QQ
            //clip的x跟y如果超過螢幕(絕對值大於1)就不用上馬賽克，怕有些角度會多出不該有的馬賽克處理
            if (noseTip.z - headCenter.z < 0 && Math.abs(headCenter.x) <= 1 && Math.abs(headCenter.y) <= 1)
                materialMosaic.uniforms.front.value = true;
            else
                materialMosaic.uniforms.front.value = false;
            materialMosaic.uniforms.gran.value = 0.01;
            //除以2是為了座標轉換，距離剩一半，本來-1~1剩下0~1
            materialMosaic.uniforms.headSize.value = 1.8 * headTop.distanceTo(headCenter) / 2;
        }

        function createSign() {
            let tex = new THREE.TextureLoader().load('./vendor/textures/room_sign.png');
            let material = new THREE.ShaderMaterial({
                // side: THREE.DoubleSide,
                uniforms: {
                    terms: {
                        type: 'i',
                        value: 5
                    },
                    time: {
                        type: 'f',
                        value: 1.0
                    },
                    scale: {
                        type: 'v2',
                        value: new THREE.Vector2(1, 1)
                    },
                    offset: {
                        type: 'v2',
                        value: new THREE.Vector2(0, 0)
                    },
                    mask: {
                        type: 't',
                        value: tex
                    }
                },
                vertexShader: document.getElementById('perlin-vs').textContent,
                fragmentShader: document.getElementById('perlin-fs').textContent,
            });
            sign = new THREE.Mesh(new THREE.PlaneGeometry(100, 50), material);
            sign.position.set(-5, 120, 98);
            sign.rotation.y = Math.PI;
            sceneColor.add(sign);
        }
    </script>
</body>