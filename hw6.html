<!DOCTYPE html>
<html>

<head>
    <title>HW6-Filter, Render Target, Normal Map</title>
    <meta charset="utf-8">
    <link rel="stylesheet" href="vendor/css/bootstrap.min.css">
    <link href="style.css" rel="stylesheet">
    <style>
        #canvas {
            margin-left: auto;
            margin-right: auto;
            display: block;
            width: 800px;
            position: absolute;
        }

        #navbar {
            position: absolute;
            width: 100%;
            text-align: center;
            margin: 0 auto;
            color: #ff0000;
            font-size: 15px;
        }

        #loading {
            z-index: 10;
            position: absolute;
            width: 100%;
            height: 100%;
            text-align: center;
            margin: 0 auto;
            color: #ffffff;
            font-size: 40px;
        }
    </style>
</head>

<body>
    <div id="canvas"></div>
    <div id="loading" class="align-middle">loading...</div>
    <div id="navbar" class="align-middle">
        Filter, Render Target, Normal Map
        <a class="nav-link" href="index.html">Home</a>
    </div>
    <script src="vendor/js/jquery-3.3.1.min.js"></script>
    <script src="vendor/js/KeyboardState.js"></script>
    <script src="https://threejs.org/build/three.min.js"></script>
    <script src="https://raw.githack.com/mrdoob/three.js/dev/examples/js/loaders/MTLLoader.js"></script>
    <script src="https://raw.githack.com/mrdoob/three.js/dev/examples/js/loaders/OBJLoader.js"></script>
    <script src="https://threejs.org/examples/js/controls/OrbitControls.js"></script>
    <script src="https://raw.githack.com/mrdoob/three.js/dev/examples/js/geometries/TeapotBufferGeometry.js"></script>

    <script id="toonVertexShader" type="x-shader/x-vertex">
        uniform vec3 lightpos;
        varying float ndotl;
        varying vec3 lightdir;
        varying vec3 eyenorm;
        varying vec2 vUv;
      
        void main() {
            gl_Position = projectionMatrix* modelViewMatrix * vec4( position, 1.0);
            vUv = uv;
            //vec4 worldpos = modelMatrix * vec4 (position, 1.0);
            //ndotl = dot (normalize(lightpos.xyz - worldpos.xyz), normal);
            vec4 eyepos = modelViewMatrix * vec4 (position, 1.0);
            vec4 lighteye = viewMatrix * vec4 (lightpos, 1.0);
            lightdir = lighteye.xyz - eyepos.xyz;
            eyenorm = normalMatrix * normal;
        }
    </script>
    <script id="toonFragmentShader" type="x-shader/x-fragment">
        varying float ndotl;
        varying vec3 lightdir;
        varying vec3 eyenorm;
        uniform sampler2D mytex;
        varying vec2 vUv;
        uniform vec3 uniColor;

        void main() {
            float nn = dot (normalize(lightdir), normalize(eyenorm));
            if (nn > 0.8) {
                nn= 1.0;
            } else if (nn > 0.6) {
                nn = 0.6;
            } else {
                nn = 0.2;
            }

            // vec4 texColor = texture2D (mytex, vUv);
            // gl_FragColor = nn*texColor;

            gl_FragColor = vec4 (nn *uniColor, 1.0);
        }
    </script>
    <script id="mono-vs" type="x-shader/x-vertex">
        varying vec2 vUv;
        void main(){
            gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
            vUv = uv;
        }
    </script>
    <script id="mono-fs" type="x-shader/x-fragment">
        uniform sampler2D texture;
        uniform vec2 imageSize;
        varying vec2 vUv;

        vec3 rgb2hsv(vec3 c) {
            vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);
            vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));
            vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));

            float d = q.x - min(q.w, q.y);
            float e = 1.0e-10;
            return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);
        }

        vec3 hsv2rgb(vec3 c) {
            vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);
            vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);
            return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);
        }
          
        void main() { 
            vec3 color = texture2D (texture, vUv).rgb;
            vec3 hh = rgb2hsv (color);
            hh.y = 0.0;
            vec3 cc = hsv2rgb (hh);
            gl_FragColor = vec4 (cc, 1.0); 
        }
    </script>
    <script>
        $("#navbar").hide();
        //檢查FPS
        javascript: (function () { var script = document.createElement('script'); script.onload = function () { var stats = new Stats(); document.body.appendChild(stats.dom); requestAnimationFrame(function loop() { stats.update(); requestAnimationFrame(loop) }); }; script.src = 'https://mrdoob.github.io/stats.js/build/stats.min.js'; document.head.appendChild(script); })();
        //必要全域變數
        //場景有三個，灰色的、影像處理的與彩色的
        var sceneGrey, scene0, sceneColor;
        //攝影機有兩台，一台照實際場景，另一台只照上了tenderTarget的板子
        var camera, camera0, renderer;
        //歐逼康輟
        var controls;
        //拿去上材質用
        var renderTarget;
        //視窗大小
        var width = window.innerWidth;// * 0.9;
        var height = window.innerHeight;// * 0.9;
        //檢查load狀態
        var loadFinish = false;
        var objNameList = [];
        var teapot;
        var scPLight;

        init();
        animate();

        function init() {
            sceneGrey = new THREE.Scene();
            $("#canvas").width(width);
            $("#canvas").height(height);
            renderer = new THREE.WebGLRenderer();
            //不自動清除畫面
            renderer.autoClear = false;
            renderer.setSize(width, height);
            renderer.setClearColor('black');
            //陰影
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = 2;
            $('#canvas').append(renderer.domElement);
            camera = new THREE.PerspectiveCamera(
                80,
                width / height,
                1,
                1000);
            camera.position.set(0, 80, -100);

            greySceneInit();
            scene0Init();
            colorSceneInit();

            //歐逼康啜
            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.name = 'controls';
            // 禁用方向鍵調整歐逼康輟位置
            controls.enableKeys = false;
        }

        function greySceneInit() {
            //環境光源
            aLight = new THREE.AmbientLight(0xffffff, 0.8);
            sceneGrey.add(aLight);

            //純喫茶
            let tryittea = buildModel();
            tryittea.castShadow = true;
            tryittea.receiveShadow = true;
            tryittea.position.set(-115, 41, 65);
            tryittea.rotation.y = -Math.PI / 6;
            sceneGrey.add(tryittea);

            //讀取 MacBookPro
            readModel("mpm_f21__Apple_MacBook_Pro_15", 'MacBookPro', 30, sceneGrey);
            objNameList.push('MacBookPro');

            //讀取椅子
            readModel("Chair", 'Chair', 55, sceneGrey);
            objNameList.push('Chair');

            //讀取床
            readModel("bed", 'bed', 110, sceneGrey, 'Y');
            objNameList.push('bed');

            /////////////////////////////////////////////

            //讀取檯燈
            readModel("Lamp", 'lamp', 30, sceneGrey, 'Z');
            objNameList.push('lamp');

            /////////////////////////////////////////////

            //讀取吊燈
            readModel("Brass_Freak", 'ceilLamp', 60, sceneGrey);
            objNameList.push('ceilLamp');

            let dLight = new THREE.DirectionalLight(0xffffff, 0.5);
            dLight.position.set(0, 100, 0);
            dLight.castShadow = true;
            dLight.shadow.camera.left = -280;
            dLight.shadow.camera.top = -260;
            dLight.shadow.camera.right = 280;
            dLight.shadow.camera.bottom = 200;
            dLight.shadow.camera.near = 1;
            dLight.shadow.camera.far = 400;
            dLight.target = sceneGrey;
            dLight.shadow.mapSize.width = dLight.shadow.mapSize.height = 1024;
            dLight.shadow.bias = -.01;
            sceneGrey.add(dLight);

            //地板
            //https://www.3dxo.com/textures/4961_wood_8
            let planeMat = new THREE.TextureLoader().load('vendor/textures/wood.jpg');
            planeMat.wrapS = THREE.RepeatWrapping;
            planeMat.wrapT = THREE.RepeatWrapping;
            planeMat.repeat.set(15, 12);
            let plane = new THREE.Mesh(new THREE.PlaneGeometry(250, 200, 4, 4),
                new THREE.MeshLambertMaterial({
                    side: THREE.DoubleSide, // 雙面材質
                    map: planeMat,
                    color: 0xF0F0F0,
                }));
            plane.rotation.x -= Math.PI / 2;
            //地板可以出現影子
            plane.receiveShadow = true;
            sceneGrey.add(plane);
            //牆壁
            let walls = [
                createWall(true, 250),
                createWall(true, 250),
                createWall(false, 200),
                createWall(false, 200)
            ];
            walls[0].position.z = 101;
            walls[1].position.z = -101;
            walls[2].position.x = 126;
            walls[3].position.x = -126;
            walls.forEach(function (wall) {
                wall.receiveShadow = true;
                sceneGrey.add(wall);
            });
            //桌子
            let desk = createDesk();
            desk.position.set(-85, 0, 70);
            sceneGrey.add(desk);
            //天花板
            let ceiling = new THREE.Mesh(
                new THREE.BoxGeometry(250, 2, 200),
                new THREE.MeshLambertMaterial({
                    color: 'beige'
                })
            );
            ceiling.position.y = 201;
            sceneGrey.add(ceiling);

            //筆筒
            let penBox = new THREE.Object3D();
            // let pens = [new THREE.Object3D(), new THREE.Object3D()];
            readModel('Pen', 'pen', 10, penBox);
            readModel('Pen', 'pen1', 10, penBox, undefined, 'Pen1');
            objNameList.push('pen', 'pen1');
            let box = createPenBox();
            penBox.add(box);

            penBox.position.set(-110, 41, 85);
            sceneGrey.add(penBox);
            //遊戲畫面rt
            gameRenderTarget = new THREE.WebGLRenderTarget(width, height);
            screen = new THREE.Mesh(
                new THREE.PlaneGeometry(28, 20),
                new THREE.MeshLambertMaterial({
                    map: gameRenderTarget.texture
                })
            );
            screen.rotation.y = Math.PI;
            screen.position.set('')
        }

        function scene0Init() {
            scene0 = new THREE.Scene();

            //左 右 上 下 near far
            camera0 = new THREE.OrthographicCamera(0, width, height, 0, -10, 100);
            // full-size RT
            renderTarget = new THREE.WebGLRenderTarget(width, height);
            greyPlane = new THREE.Mesh(
                new THREE.PlaneGeometry(width, height),
                new THREE.ShaderMaterial({
                    uniforms: {
                        imageSize: {
                            type: 'v2',
                            value: new THREE.Vector2(width, height)
                        },
                        texture: {
                            type: 't',
                            value: renderTarget.texture
                        }
                    },
                    vertexShader: document.getElementById('mono-vs').textContent,
                    fragmentShader: document.getElementById('mono-fs').textContent,
                    depthTest: false,  // no depth test
                    depthWrite: false  // do not write depth buffer
                })
            );
            greyPlane.position.set(width / 2, height / 2, 0);
            scene0.add(greyPlane);
        }

        function colorSceneInit() {
            sceneColor = new THREE.Scene();
            var geometry = new THREE.TeapotBufferGeometry(5);
            var material = new THREE.ShaderMaterial({
                uniforms: {
                    lightpos: { type: 'v3', value: new THREE.Vector3() },
                    shading: { type: 'i', value: 1 },
                    coordinate: { type: 'i', value: 0 },
                    uniColor: { type: 'v3', value: new THREE.Vector3(161, 37, 13).multiplyScalar(1 / 255) }
                },
                vertexShader: document.getElementById('toonVertexShader').textContent,
                fragmentShader: document.getElementById('toonFragmentShader').textContent,
            });
            teapot = new THREE.Mesh(geometry, material);
            let box3 = new THREE.Box3();
            box3.setFromObject(teapot);
            let teapotSize = new THREE.Vector3().subVectors(box3.max, box3.min);
            teapot.position.set(-60, 40 + teapotSize.y / 2, 60);
            sceneColor.add(teapot);
            //用pointLight測試
            // scPLight = new THREE.PointLight(0xffffff, 1.1);
            // scPLight.angle = 0;
            // sceneColor.add(scPLight);
            // sceneColor.add(new THREE.PointLightHelper(scPLight, 2));

            //假裝光源從正上方打下來
            teapot.material.uniforms.lightpos.value.set(-60, 100, 60);
        }

        function createDesk() {
            //https://wallpapersafari.com/w/Khy9xa
            let texture = new THREE.TextureLoader().load('vendor/textures/desk.jpg');
            let desk = new THREE.Object3D;
            let desktopmaterial = new THREE.MeshLambertMaterial({
                map: texture
            });
            let cylinderMaterial = new THREE.MeshLambertMaterial({
                color: 0x664200
            });
            let desktop = new THREE.Mesh(new THREE.BoxGeometry(80, 2, 60), desktopmaterial);
            desktop.position.y = 40;
            let c1 = new THREE.Mesh(new THREE.CylinderGeometry(1.5, 1.5, 40, 30), cylinderMaterial);
            let c2 = new THREE.Mesh(new THREE.CylinderGeometry(1.5, 1.5, 40, 30), cylinderMaterial);
            let c3 = new THREE.Mesh(new THREE.CylinderGeometry(1.5, 1.5, 40, 30), cylinderMaterial);
            let c4 = new THREE.Mesh(new THREE.CylinderGeometry(1.5, 1.5, 40, 30), cylinderMaterial);
            c1.position.set(35, 20, 25);
            c2.position.set(35, 20, -25);
            c3.position.set(-35, 20, -25);
            c4.position.set(-35, 20, 25);
            desk.add(desktop, c1, c2, c3, c4);
            desk.traverse(function (obj) {
                obj.castShadow = true;
                obj.receiveShadow = true;
            });
            return desk;
        }

        function createWall(rotation, width = 300, height = 200) {
            let wall = new THREE.Mesh(
                new THREE.BoxGeometry(2, height, width),
                new THREE.MeshLambertMaterial({
                    color: 'beige'
                })
            );
            wall.position.y = height / 2;
            if (rotation) {
                wall.rotation.y = Math.PI / 2;

            }
            wall.receiveShadow = true;
            return wall;
        }

        function createPenBox() {
            let penBox = new THREE.Object3D();
            let texture = new THREE.TextureLoader().load('vendor/textures/woodcutout.png')
            let material = new THREE.MeshPhongMaterial({ side: THREE.DoubleSide, map: texture, alphaTest: 0.5 });
            let f1 = new THREE.Mesh(new THREE.BoxGeometry(0.05, 8, 6.05), material);
            let f2 = new THREE.Mesh(new THREE.BoxGeometry(0.05, 8, 6.05), material);
            let f3 = new THREE.Mesh(new THREE.BoxGeometry(6.05, 8, 0.05), material);
            let f4 = new THREE.Mesh(new THREE.BoxGeometry(6.05, 8, 0.05), material);
            let f5 = new THREE.Mesh(new THREE.BoxGeometry(6, 0.05, 6), material);
            f1.position.set(3, 4, 0);
            f2.position.set(-3, 4, 0);
            f3.position.set(0, 4, 3);
            f4.position.set(0, 4, -3);
            penBox.add(f1, f2, f3, f4, f5);
            penBox.traverse(function (obj) {
                obj.castShadow = true;
                obj.receiveShadow = true;
            });
            return penBox;
        }

        function createFace(one, two, three, index = 0) {
            let face = new THREE.Face3(one, two, three);
            face.materialIndex = index;
            return face;
        }

        function createTextureMaterial(map, alphaTest = 1) {
            //用Lambert，新鮮屋弄上油墨，不太反光ㄉ
            let material = new THREE.MeshLambertMaterial({
                map: map,
                alphaTest: alphaTest
            });
            return material;
        }

        function buildModel() {
            let geometry = new THREE.Geometry();
            //斜邊高度
            let sq375 = Math.sqrt(3.75);

            //放入頂點
            geometry.vertices.push(new THREE.Vector3(-3.5, 0, 3.5));
            geometry.vertices.push(new THREE.Vector3(3.5, 0, 3.5));
            geometry.vertices.push(new THREE.Vector3(3.5, 10.5, 3.5));
            geometry.vertices.push(new THREE.Vector3(3.5, 10.5 + sq375, 0));
            geometry.vertices.push(new THREE.Vector3(-3.5, 10.5 + sq375, 0));
            geometry.vertices.push(new THREE.Vector3(-3.5, 10.5, 3.5));

            geometry.vertices.push(new THREE.Vector3(-3.5, 0, -3.5));
            geometry.vertices.push(new THREE.Vector3(3.5, 0, -3.5));
            geometry.vertices.push(new THREE.Vector3(3.5, 10.5, -3.5));
            geometry.vertices.push(new THREE.Vector3(-3.5, 10.5, -3.5));

            //中間一點讓兩邊可以上三角形做開喝飲料的位置
            geometry.vertices.push(new THREE.Vector3(0, 10.5 + sq375, 0));

            //最上面一條橫條黏膠的部分
            geometry.vertices.push(new THREE.Vector3(3.5, 10.5 + sq375 + 1.5, 0));
            geometry.vertices.push(new THREE.Vector3(-3.5, 10.5 + sq375 + 1.5, 0));

            //正面
            geometry.faces.push(createFace(0, 1, 2));
            geometry.faces.push(createFace(0, 2, 5));

            //背面
            geometry.faces.push(createFace(7, 6, 9));
            geometry.faces.push(createFace(7, 9, 8));

            //右面
            geometry.faces.push(createFace(1, 7, 8));
            geometry.faces.push(createFace(1, 8, 2));

            //左面
            geometry.faces.push(createFace(6, 0, 5));
            geometry.faces.push(createFace(6, 5, 9));

            //正面斜邊
            geometry.faces.push(createFace(5, 2, 3));
            geometry.faces.push(createFace(5, 3, 4));

            //背面斜邊
            geometry.faces.push(createFace(8, 9, 4));
            geometry.faces.push(createFace(8, 4, 3));

            //上面橫條
            geometry.faces.push(createFace(4, 3, 11));
            geometry.faces.push(createFace(4, 11, 12));
            //上面橫條後面
            geometry.faces.push(createFace(3, 4, 12));
            geometry.faces.push(createFace(3, 12, 11));

            /*----右面折進去的的三面，同一面----*/
            //靠前的背對的面
            geometry.faces.push(createFace(2, 10, 3));
            //中間的面
            geometry.faces.push(createFace(2, 8, 10));
            // //靠後的正對的面
            geometry.faces.push(createFace(8, 3, 10));

            /*----左面折進去的的三面，同一面----*/
            //靠後的正對的面
            geometry.faces.push(createFace(9, 10, 4));
            //中間的面
            geometry.faces.push(createFace(9, 5, 10));
            //靠前的背對的面
            geometry.faces.push(createFace(5, 4, 10));

            //底部
            geometry.faces.push(createFace(6, 7, 1));
            geometry.faces.push(createFace(6, 1, 0));

            //上材質
            //材質高度幾分之幾
            let h1 = 1035 / 1600;/*1035/1600 底部到斜邊*/
            let h2 = 1445 / 1600;/*1445/1600 斜邊到封條下*/
            let h3 = 7 / 16;/* 底下的正方形*/
            //正面
            geometry.faceVertexUvs[0].push([
                new THREE.Vector2(0, 0),
                new THREE.Vector2(0.2, 0),
                new THREE.Vector2(0.2, h1)
            ]);
            geometry.faceVertexUvs[0].push([
                new THREE.Vector2(0, 0),
                new THREE.Vector2(0.2, h1),
                new THREE.Vector2(0, h1)
            ]);
            //背面
            geometry.faceVertexUvs[0].push([
                new THREE.Vector2(0.4, 0),
                new THREE.Vector2(0.6, 0),
                new THREE.Vector2(0.6, h1)
            ]);
            geometry.faceVertexUvs[0].push([
                new THREE.Vector2(0.4, 0),
                new THREE.Vector2(0.6, h1),
                new THREE.Vector2(0.4, h1)
            ]);
            //右面
            geometry.faceVertexUvs[0].push([
                new THREE.Vector2(0.2, 0),
                new THREE.Vector2(0.4, 0),
                new THREE.Vector2(0.4, h1)
            ]);
            geometry.faceVertexUvs[0].push([
                new THREE.Vector2(0.2, 0),
                new THREE.Vector2(0.4, h1),
                new THREE.Vector2(0.2, h1)
            ]);
            //左面
            geometry.faceVertexUvs[0].push([
                new THREE.Vector2(0.6, 0),
                new THREE.Vector2(0.8, 0),
                new THREE.Vector2(0.8, h1)
            ]);
            geometry.faceVertexUvs[0].push([
                new THREE.Vector2(0.6, 0),
                new THREE.Vector2(0.8, h1),
                new THREE.Vector2(0.6, h1)
            ]);
            //正面斜邊
            geometry.faceVertexUvs[0].push([
                new THREE.Vector2(0, h1),
                new THREE.Vector2(0.2, h1),
                new THREE.Vector2(0.2, h2)
            ]);
            geometry.faceVertexUvs[0].push([
                new THREE.Vector2(0, h1),
                new THREE.Vector2(0.2, h2),
                new THREE.Vector2(0, h2)
            ]);
            //背面斜邊
            geometry.faceVertexUvs[0].push([
                new THREE.Vector2(0.4, h1),
                new THREE.Vector2(0.6, h1),
                new THREE.Vector2(0.6, h2)
            ]);
            geometry.faceVertexUvs[0].push([
                new THREE.Vector2(0.4, h1),
                new THREE.Vector2(0.6, h2),
                new THREE.Vector2(0.4, h2)
            ]);
            //上面橫條正面
            geometry.faceVertexUvs[0].push([
                new THREE.Vector2(0, h2),
                new THREE.Vector2(0.2, h2),
                new THREE.Vector2(0.2, 1)
            ]);
            geometry.faceVertexUvs[0].push([
                new THREE.Vector2(0, h2),
                new THREE.Vector2(0.2, 1),
                new THREE.Vector2(0, 1)
            ]);
            //上面橫條後面
            geometry.faceVertexUvs[0].push([
                new THREE.Vector2(0.4, h2),
                new THREE.Vector2(0.6, h2),
                new THREE.Vector2(0.6, 1)
            ]);
            geometry.faceVertexUvs[0].push([
                new THREE.Vector2(0.4, h2),
                new THREE.Vector2(0.6, 1),
                new THREE.Vector2(0.4, 1)
            ]);
            //右邊內凹
            geometry.faceVertexUvs[0].push([
                new THREE.Vector2(0.2, h1),
                new THREE.Vector2(0.3, h2),
                new THREE.Vector2(0.2, h2)
            ]);
            geometry.faceVertexUvs[0].push([
                new THREE.Vector2(0.2, h1),
                new THREE.Vector2(0.4, h1),
                new THREE.Vector2(0.3, h2)
            ]);
            geometry.faceVertexUvs[0].push([
                new THREE.Vector2(0.4, h1),
                new THREE.Vector2(0.4, h2),
                new THREE.Vector2(0.3, h2)
            ]);
            //左邊內凹
            geometry.faceVertexUvs[0].push([
                new THREE.Vector2(0.6, h1),
                new THREE.Vector2(0.7, h2),
                new THREE.Vector2(0.6, h2)
            ]);
            geometry.faceVertexUvs[0].push([
                new THREE.Vector2(0.6, h1),
                new THREE.Vector2(0.8, h1),
                new THREE.Vector2(0.7, h2)
            ]);
            geometry.faceVertexUvs[0].push([
                new THREE.Vector2(0.8, h1),
                new THREE.Vector2(0.8, h2),
                new THREE.Vector2(0.7, h2)
            ]);
            //底部
            geometry.faceVertexUvs[0].push([
                new THREE.Vector2(0.8, 0),
                new THREE.Vector2(1, 0),
                new THREE.Vector2(1, h3)
            ]);
            geometry.faceVertexUvs[0].push([
                new THREE.Vector2(0.8, 0),
                new THREE.Vector2(1, h3),
                new THREE.Vector2(0.8, h3)
            ]);
            //要先計算Face然後再計算頂點，這樣才能知道要光源要怎計算
            geometry.computeFaceNormals();
            geometry.computeVertexNormals();

            let loader = new THREE.TextureLoader();
            loader.crossOrigin = '';
            let mergeTexture = loader.load('vendor/textures/TryItTea/tryittea.png');
            materialArray = [];
            materialArray.push(
                createTextureMaterial(mergeTexture, 0.5)
            );
            return new THREE.Mesh(geometry, materialArray);
        }

        function readModel(modelName, objName = 'OBJ', targetSize = 40, parent, turn = undefined, mtlName = undefined) {
            var onProgress = function (xhr) {
                if (xhr.lengthComputable) {
                    var percentComplete = xhr.loaded / xhr.total * 100;
                    console.log(Math.round(percentComplete, 2) + '% downloaded');
                }
            };

            var onError = function (xhr) { };

            var mtlLoader = new THREE.MTLLoader();

            let mtl = modelName;
            if (mtlName !== undefined) {
                mtl = mtlName;
            }
            mtlLoader.setPath('vendor/models/' + modelName + '/');
            mtlLoader.load(mtl + '.mtl', function (materials) {

                materials.preload();

                var objLoader = new THREE.OBJLoader();
                objLoader.setMaterials(materials);
                objLoader.setPath('vendor/models/' + modelName + '/');
                objLoader.load(modelName + '.obj', function (object) {
                    console.log("model name:" + modelName);
                    theObject = unitize(object, targetSize);
                    // theObject.add(new THREE.BoxHelper(theObject));
                    theObject.name = objName;
                    theObject.traverse(function (object) {
                        if (object instanceof THREE.Mesh) {
                            object.castShadow = true
                            object.receiveShadow = true
                        }
                    })
                    //把這個model放入父層
                    parent.add(theObject);
                    //不須改變軸的方向
                    if (turn !== undefined) {
                        if (turn.toUpperCase() == 'X') {
                            theObject.setRotationFromEuler(new THREE.Euler(Math.PI / 2, 0, 0))
                            console.log("----" + modelName + ' to turn ' + turn);
                        }
                        else if (turn.toUpperCase() == 'Y') {
                            theObject.setRotationFromEuler(new THREE.Euler(0, Math.PI / 2, 0))
                            console.log("----" + modelName + ' to turn ' + turn);
                        }
                        else if (turn.toUpperCase() == 'Z') {
                            theObject.setRotationFromEuler(new THREE.Euler(0, 0, Math.PI / 2))
                            console.log("----" + modelName + ' to turn ' + turn);
                        }
                    }
                }, onProgress, onError);

            });
        }

        ////////////////////////////////////////
        // wrap an Object3D around the given object
        // so that it is centered at +Y axis
        //
        function unitize(object, targetSize) {

            // find bounding box of 'object'
            var box3 = new THREE.Box3();
            box3.setFromObject(object);
            var size = new THREE.Vector3();
            size.subVectors(box3.max, box3.min);
            var center = new THREE.Vector3();
            center.addVectors(box3.max, box3.min).multiplyScalar(0.5);
            console.log('center: ' + center.x + ', ' + center.y + ', ' + center.z);
            console.log('size: ' + size.x + ', ' + size.y + ', ' + size.z);

            // uniform scaling according to objSize
            var objSize = Math.max(size.x, size.y, size.z);
            var scaleSet = targetSize / objSize;
            var theObject = new THREE.Object3D();
            theObject.add(object);
            object.scale.set(scaleSet, scaleSet, scaleSet);
            object.position.set(-center.x * scaleSet, 0, -center.z * scaleSet);

            object.rotation.y = Math.PI / 2;

            // let axis = new THREE.AxesHelper(10);
            // theObject.add(axis);

            //get now size

            // carSize = size.multiplyScalar(scaleSet);

            return theObject;
        }

        function animate() {
            if (!loadFinish) {
                let isOK = true;
                objNameList.forEach(function (name) {
                    if (sceneGrey.getObjectByName(name) === undefined) {
                        isOK = false;
                    }
                });
                if (isOK) {
                    //loading結束
                    document.getElementById("loading").style.display = "none";
                    $("#navbar").show();
                    ///////////////////////////////////
                    initPosition();
                    //初始化完畢
                    loadFinish = !loadFinish;
                }
            } else {
                render();
                // turnPointLight(scPLight, new THREE.Vector3(-60, 80, 60), 30, 0.02);
            }
            requestAnimationFrame(animate);
        }

        function initPosition() {
            let MacBookPro = sceneGrey.getObjectByName('MacBookPro');
            MacBookPro.position.set(-90, 41, 60);
            MacBookPro.rotation.y = Math.PI / 2;
            let pen = sceneGrey.getObjectByName('pen');
            pen.position.set(0.5, 3, -0.5);
            pen.rotation.x = Math.PI / 7.5;
            let pen1 = sceneGrey.getObjectByName('pen1');
            pen1.position.set(-1.7, 3, 0.6);
            pen1.rotation.y = Math.PI * 3 / 2;
            pen1.rotation.z = Math.PI / 3.5
            let ceilLamp = sceneGrey.getObjectByName('ceilLamp');
            ceilLamp.position.y = 200;
            let deskLamp = sceneGrey.getObjectByName('lamp');
            deskLamp.position.set(-50, 41, 80);
            deskLamp.rotation.y = Math.PI * 3 / 4;
            let chair = sceneGrey.getObjectByName('Chair');
            chair.position.set(-90, 0, 40);
            chair.rotation.y = -Math.PI / 2;
            let bed = sceneGrey.getObjectByName('bed');
            bed.position.set(135, -0.5, 110.5);
            bed.rotation.y = Math.PI / 2;
        }

        function render() {
            //換去渲染plane的tex
            renderer.setRenderTarget(renderTarget);
            renderer.clear();
            //這次要上色，要讓板子能夠有畫面出來
            sceneGrey.traverse(function (obj) {
                if (obj instanceof THREE.Mesh) {
                    if (obj.material instanceof Array) {
                        obj.material.forEach(function (mat) {
                            mat.colorWrite = true;
                        });
                    } else {
                        obj.material.colorWrite = true;
                    }
                }
            });

            renderer.render(sceneGrey, camera);

            //換去渲染螢幕
            renderer.setRenderTarget(null);

            renderer.clearColor();
            //渲染板子出來
            renderer.render(scene0, camera0);

            //這次渲染只做depth test(只看z-buffer)
            sceneGrey.traverse(function (obj) {
                if (obj instanceof THREE.Mesh) {
                    if (obj.material instanceof Array) {
                        obj.material.forEach(function (mat) {
                            mat.colorWrite = false;
                        });
                    } else {
                        obj.material.colorWrite = false;
                    }
                }
            });
            renderer.render(sceneGrey, camera);

            renderer.render(sceneColor, camera);
        }

        function turnPointLight(light, center, radius, speed) {
            light.position.set(center.x, center.y, center.z);
            light.position.addVectors(center, new THREE.Vector3(radius * Math.cos(light.angle), 0, radius * Math.sin(light.angle)));
            light.angle += speed;
        }
    </script>
</body>