<!DOCTYPE html>

<html>

<head>
    <title>HW5-1 Basic GLSL</title>
    <meta charset="utf-8">
    <link rel="stylesheet" href="vendor/css/bootstrap.min.css">
    <link href="style.css" rel="stylesheet">
    <style>
        #info {
            position: absolute;
            width: 100%;
            text-align: center;
            margin: 0 auto;
            color: #38ff7a;
            font-size: 20px;
            z-index: 10;
            padding-top: 2vh;
        }

        #canvas {
            margin: 0 auto;
            display: block;
            position: absolute;
            width: 100%;
            height: 100%;
        }

        #info a {
            font-size:15px;
            color: yellow;
        }


        body {
            overflow: hidden;
        }
    </style>
</head>

<body>
    <div id="info">HW5-1 Basic GLSL<br>
        <a href="index.html">home</a><br>
        <select id='coords' class="custom-select">
            <option value="obj" selected>Object Coordinate</option>
            <option value="world">World Coordinate</option>
            <option value="eye">Eye Coordinate</option>
        </select>
        <select id='shading' class="custom-select">
            <option value='perVertex' selected>Per Vertex</option>
            <option value='perPixel'>Per Pixel</option>
        </select>
    </div>
    <div id="canvas"></div>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/109/three.min.js"></script>
    <script src="https://threejs.org/examples/js/controls/OrbitControls.js"></script>
    <script src="https://code.jquery.com/jquery-2.1.4.min.js"></script>
    <script src="https://raw.githack.com/mrdoob/three.js/dev/examples/js/geometries/TeapotBufferGeometry.js"></script>

    <script id="myVertexShader" type="x-shader/x-vertex">
        uniform int shading;
        uniform int coordinate;
        varying vec3 color;
        varying vec4 objpos;
        varying vec4 worldpos;
        varying vec4 eyepos;

        void perVertexShading(vec3 objpos, vec3 worldpos) {
            if (coordinate == 0) {
                //物件座標
                if (objpos.x > 0.0) 
                    color = vec3 (1,1,1);
                else
                    color = vec3 (0,0,0);
            } else if (coordinate == 1) {
                //世界座標
                if (worldpos.x > 0.0) 
                    color = vec3 (1,1,1);
                else
                    color = vec3 (0,0,0);    	
            } else if (coordinate == 2) {
                //眼睛座標(直接拿varying變數，於main已經算好)
                if (eyepos.x > 0.0) 
                    color = vec3 (1,1,1);
                else
                    color = vec3 (0,0,0);    	
            }
        }
        
        void main() {
            gl_Position = projectionMatrix* modelViewMatrix * vec4(position, 1.0);
            objpos = vec4(position, 1.0);
            worldpos = modelMatrix * vec4(position, 1.0);
            eyepos = modelViewMatrix * vec4(position, 1.0);
            if (shading == 0)  // per-vertex shading
                perVertexShading(position, worldpos.xyz);
        }
    </script>

    <script id="myFragmentShader" type="x-shader/x-fragment">
        uniform int shading;
        uniform int coordinate;
        //用頂點上的色
        varying vec3 color;

        //傳到fragment像素做處理
        //物件座標
        varying vec4 objpos;
        //世界座標
        varying vec4 worldpos;
        //眼睛座標
        varying vec4 eyepos;

        void main() {
            if(shading==0){
                //從Vertex下手
                gl_FragColor = vec4 (color, 1.0);
            }else{
                // your homework
                //perPixelShading移到這裡
                vec3 fragcolor;
                //從Pixel下手
                if (coordinate == 0) {
                    if (objpos.x > 0.0) 
                        fragcolor = vec3 (1,1,1);
                    else
                        fragcolor = vec3 (0,0,0);
                } else if (coordinate == 1) {
                    if (worldpos.x > 0.0) 
                        fragcolor = vec3 (1,1,1);
                    else
                        fragcolor = vec3 (0,0,0);    	
                } else if (coordinate == 2) {
                    if (eyepos.x > 0.0) 
                        fragcolor = vec3 (1,1,1);
                    else
                        fragcolor = vec3 (0,0,0);    	
                }
                gl_FragColor = vec4 (fragcolor, 1.0);
            }
        }
    </script>

    <script>

        $('#coords').change(function () {
            console.log($(this).val());
            let objType = $(this).val();
            if (objType === 'obj') {
                teapotMaterial.uniforms.coordinate.value = 0;
            } else if (objType === 'world') {
                teapotMaterial.uniforms.coordinate.value = 1;
            } else if (objType === 'eye') {
                teapotMaterial.uniforms.coordinate.value = 2;
            }
        });

        $('#shading').change(function () {
            console.log($(this).val());
            let objType = $(this).val();
            if (objType === 'perVertex') {
                teapotMaterial.uniforms.shading.value = 0;
            } else if (objType === 'perPixel') {
                teapotMaterial.uniforms.shading.value = 1;
            }
        });


        var scene, renderer, camera;
        var movingTeapot;
        var angle = 0;
        var teapotMaterial;

        init();
        animate();

        function init() {
            var width = window.innerWidth;
            var height = window.innerHeight;

            renderer = new THREE.WebGLRenderer({
                antialias: true
            });
            renderer.setSize(width, height);
            renderer.setClearColor(0x888888);
            $('#canvas').append(renderer.domElement);

            scene = new THREE.Scene();

            camera = new THREE.PerspectiveCamera(45, width / height, 0.1, 10000);
            camera.position.set(0, 50, 200);
            camera.lookAt(new THREE.Vector3(0, 0, 0));

            controls = new THREE.OrbitControls(camera, renderer.domElement);

            var gridXZ = new THREE.GridHelper(200, 20, 'red', 'white');
            scene.add(gridXZ);

            pointLight = new THREE.PointLight(0xffffff);
            pointLight.position.set(200, 300, 200);
            scene.add(pointLight);
            var ambientLight = new THREE.AmbientLight(0x111111);
            scene.add(ambientLight);

            /////////////////////////////////////////////////////////////////


            teapotMaterial = new THREE.ShaderMaterial({
                uniforms: {
                    lightpos: { type: 'v3', value: new THREE.Vector3(0, 30, 20) },
                    shading: { type: 'i', value: 0 },
                    coordinate: { type: 'i', value: 0 },
                },
                vertexShader: document.getElementById('myVertexShader').textContent,
                fragmentShader: document.getElementById('myFragmentShader').textContent
            });

            movingTeapot = new THREE.Mesh(new THREE.TeapotBufferGeometry(10), teapotMaterial);
            staticTeapot = new THREE.Mesh(
                new THREE.TeapotBufferGeometry(10),
                new THREE.MeshPhongMaterial({
                    color: 0x333333
                })
            );
            scene.add(movingTeapot, staticTeapot);
        }

        function animate() {

            angle += 0.01;

            // update the uniform variable

            if (movingTeapot !== undefined) {
                movingTeapot.position.set(70 * Math.cos(angle), 0, 70 * Math.sin(angle));
            }

            requestAnimationFrame(animate);
            renderer.render(scene, camera);

        }

    </script>
</body>

</html>