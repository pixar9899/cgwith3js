<!DOCTYPE html>
<html>

<head>
    <title>HW1-time-based animation</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
    <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css">
    <link href="style.css" rel="stylesheet">
    <style>
        #canvas {
            padding: 25px 0;
            margin-left: auto;
            margin-right: auto;
            display: block;
            width: 800px;
        }

        /* 增加button間距 */
        #navbtn button {
            margin: 0 10px;
        }
    </style>
</head>

<body>
    <nav class="navbar navbar-expand-lg navbar-dark bg-dark">
        <div class="container">
            <span class="navbar-brand">Time-based animation</span>
            <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNav"
                aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation">
                <span class="navbar-toggler-icon"></span>
            </button>
            <div class="collapse navbar-collapse">
                <ul class="navbar-nav">
                    <li class="nav-item">
                        <a class="nav-link" href="index.html">Home</a>
                    </li>
                </ul>
            </div>
            <span class="text-white nav-text">按Z鍵可暫停/轉動</span>
            <div id="navbtn">
                <button id="turnbtn" class="btn btn-primary">暫停</button>
                <button id="modebtn" class="btn btn-info">連續</button>
                <button id="calcbtn" class="btn btn-success">時間運算</button>
            </div>
        </div>
    </nav>
    <div id="canvas"></div>
    <script src="https://code.jquery.com/jquery-3.3.1.slim.min.js"></script>
    <script src="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/js/bootstrap.min.js"></script>
    <script src="https://jyunming-chen.github.io/tutsplus/js/KeyboardState.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/108/three.min.js"></script>
    <script>
        //檢查FPS
        javascript: (function () { var script = document.createElement('script'); script.onload = function () { var stats = new Stats(); document.body.appendChild(stats.dom); requestAnimationFrame(function loop() { stats.update(); requestAnimationFrame(loop) }); }; script.src = 'https://mrdoob.github.io/stats.js/build/stats.min.js'; document.head.appendChild(script); })();
        var scene, renderer, camera;
        //指針,背板
        var pointer, backplane;
        //啟動前一次的時間點
        var preTime = Date.now();
        //紀錄上次暫停時的角度
        var preAngle = 0;
        //鍵盤事件
        var keyboard = new KeyboardState();
        //是否要轉動；選擇用什麼方式運作,0是連續,1是跳動；計算方式,0是時間,1是FPS
        var isturn = false, mode = 0, calc = 0;
        init();
        animate();

        function init() {
            scene = new THREE.Scene();

            // var width = window.innerWidth;
            // var height = window.innerHeight;
            var width = 800;
            var height = 600;
            renderer = new THREE.WebGLRenderer();
            renderer.setSize(width, height);
            renderer.setClearColor('darkgray');
            $("#canvas").append(renderer.domElement);

            camera = new THREE.PerspectiveCamera(
                50,
                width / height,
                10,
                100
            );
            //看著場景的中心點(0,0,0)
            camera.lookAt(scene.position);
            //擺放位置
            camera.position.set(0, 0, 50);

            //背板
            backplane = new THREE.Mesh(new THREE.CircleGeometry(20, 64),
                new THREE.MeshBasicMaterial({
                    color: 0xDADDDD
                }));
            scene.add(backplane);

            //完整指針
            pointer = new THREE.Group();
            //指針柄
            // var handle=new THREE.BoxGeometry(1,10,1)//x,y,z
            var handle = new THREE.Mesh(new THREE.BoxGeometry(0.5, 10, 0.5),
                new THREE.MeshBasicMaterial({
                    color: "gray"
                }));
            handle.position.set(0, 5, 0.5);
            pointer.add(handle);
            //箭頭
            var arrow = new THREE.Mesh(new THREE.ConeGeometry(0.5, 5, 64),
                new THREE.MeshBasicMaterial({
                    color: 0x727D82
                }));
            //10+2.5
            arrow.position.set(0, 12.5, 0.5);
            //指針箭頭
            pointer.add(arrow);
            //完整指針放到場景
            scene.add(pointer);
        }

        function animate() {
            //鍵盤事件
            keyboard.update()
            if (keyboard.down("Z")) {
                if (!isturn) {
                    $("#turnbtn").text("轉動");
                    //恢復轉動時，要將目前的時間當作起點時間
                    preTime = Date.now();
                } else {
                    $("#turnbtn").text("暫停");
                }
                isturn = !isturn;
            }
            //渲染畫面
            renderer.render(scene, camera);
            //轉動
            if (isturn) {
                //模式
                if (mode) {
                    jump();
                } else {
                    turn();
                }
            }
            requestAnimationFrame(animate);
        }

        function jump() {
            var difference = Date.now() - preTime;
            //至少一秒過後才轉動(跳動)一次
            if (difference >= 1000) {
                //FPS運算直接2PI/60(秒)
                if (calc) {
                    var angle = Math.PI * 2 / 60;
                    console.log("跳動:FPS");
                }
                //每幀的時間差算出角度
                else {
                    var angle = Math.PI * 2 / 60000 * difference - preAngle;
                    console.log("跳動:time");
                }
                pointer.rotation.z -= angle;
                preTime = Date.now()
            }
        }

        function turn() {

            //2PI/60秒/FPS60
            //Math.PI * 2 / 60 / 60
            if (calc) {
                var angle = Math.PI * 2 / 60 / 60;
                console.log("連續:FPS");
            }
            //時間差做角度計算
            //1min=1*60sec=60*1000ms=60000ms
            //   PI*2          目前要轉的角度
            //----------  =  -----------------
            // 60000毫秒      每次animate時間差
            else {
                var difference = Date.now() - preTime;
                //補上preAngle的角度才吻合暫停後再開始的樣子
                var angle = Math.PI * 2 / 60000 * (difference) - preAngle;
                console.log("連續:time");
            }
            pointer.rotation.z -= angle;
            preTime = Date.now()
        }

        //這邊如同按下Z鍵一樣的做法
        $("#turnbtn").click(function () {
            if (!isturn) {
                $("#turnbtn").text("轉動");
                //恢復轉動時，要將目前的時間當作起點時間
                preTime = Date.now();
            } else {
                $("#turnbtn").text("暫停");
            }
            isturn = !isturn;
        })

        $("#modebtn").click(function () {
            //改成跳動
            if (mode == 0) {
                $("#modebtn").text("跳動");
                mode = 1;
            }
            //改成連續
            else {
                $("#modebtn").text("連續");
                mode = 0;
            }
        })

        $("#calcbtn").click(function () {
            //改成跳動
            if (calc == 0) {
                $("#calcbtn").text("60FPS運算");
                calc = 1;
            }
            //改成連續
            else {
                $("#calcbtn").text("時間運算");
                calc = 0;
            }
        })
    </script>
</body>

</html>