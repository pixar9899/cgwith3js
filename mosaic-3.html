<!DOCTYPE html>

<html>

<head>
    <style>
        body {
            background-color: #fff;
            color: #111;
            margin: 0px;
            overflow: hidden;
            font-family: Monospace;
            font-size: 20px;
            position: absolute;
        }

        #info {
            position: absolute;
            top: 0px;
            width: 100%;
            padding: 5px;
            text-align: center;
            color: #ffff00
        }
    </style>
</head>

<body>
    <div id="info">
        <br /> RTT, Mosaic
        <br />
    </div>
    <script src="https://threejs.org/build/three.min.js"></script>
    <script src="https://threejs.org/examples/js/controls/OrbitControls.js">
    </script>

    <script id="vs-mosaic" type="x-shader/x-vertex">
        varying vec2 vUv; 
        void main() { 
            gl_Position = projectionMatrix* modelViewMatrix * vec4( position, 1.0); 
            vUv = uv; 
        }
    </script>
    <script id="fs-mosaic" type="x-shader/x-fragment">
        uniform sampler2D texture; 
        varying vec2 vUv; 
        uniform float gran;
        vec2 vUvm;
        uniform vec2 headNDC;
        uniform float headSize;
        uniform bool front;

        void main() {
            if(front){
                float d = distance (headNDC, vUv);
                float borderWidth = headSize*0.1; 
                if (d < headSize) {
                    vUvm = floor (vUv/gran)*gran;
                    gl_FragColor = texture2D(texture, vUvm);
                } else if (d < headSize+borderWidth) {
                    gl_FragColor = vec4(1,0,0,1);
                } else {
                    vUvm = vUv;
                    gl_FragColor = texture2D(texture, vUvm);
                }
            }
            else{
                //如果看不到臉直接把材質貼回去
                gl_FragColor = texture2D(texture, vUv);
            }
        }
    </script>

    <script>
        var scene, renderer, camera;
        var materialMosaic;
        var sceneRTT, cameraRTT;
        var renderTargetMosaic;
        var miku;
        var angle = 0;

        init();
        animate();

        function init() {
            renderer = new THREE.WebGLRenderer({
                antialias: true
            });
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.body.appendChild(renderer.domElement);
            renderer.setClearColor(0x888888);

            sceneMosaic = new THREE.Scene();

            camera = new THREE.PerspectiveCamera(80, window.innerWidth / window.innerHeight, 1, 1000);
            //camera.position.y = 80;
            camera.position.z = 100;
            camera.lookAt(new THREE.Vector3(0, 0, 0));

            let controls = new THREE.OrbitControls(camera, renderer.domElement);

            window.addEventListener('resize', onWindowResize, false);

            ///////////////////////////////////////////////////////
            sceneColor = new THREE.Scene();
            sceneColor.add(new THREE.GridHelper(200, 20, 'red', 'white'));
            miku = new THREE.Group();
            torso = new THREE.Mesh(new THREE.CylinderGeometry(10, 10, 40), new THREE.MeshNormalMaterial());
            torso.position.y = 20;

            head = new THREE.Mesh(new THREE.SphereGeometry(15, 20, 20), new THREE.MeshNormalMaterial());
            head.position.y = 40;

            nose = new THREE.Mesh(new THREE.CylinderGeometry(0, 8, 10), new THREE.MeshNormalMaterial());
            nose.position.set(0, 40, 15);
            nose.rotation.x = Math.PI / 2;

            miku.add(nose, head, torso);
            sceneColor.add(miku);

            renderTargetMosaic = new THREE.WebGLRenderTarget(1024, 1024);//256,256); 

            var uniforms = {
                headNDC: {
                    type: 'v2',
                    value: null
                },
                headSize: {
                    type: 'f',
                    value: 0
                },
                texture: {
                    type: 't',
                    value: renderTargetMosaic.texture
                },
                gran: {
                    type: 'f',
                    value: 0
                },
                front: {
                    type: 'b',
                    value: false
                }
            };

            var vertShader = document.getElementById('vs-mosaic').innerHTML;
            var fragShader = document.getElementById('fs-mosaic').innerHTML;
            materialMosaic = new THREE.ShaderMaterial({
                uniforms: uniforms,
                vertexShader: vertShader,
                fragmentShader: fragShader
            });
            //設為跟螢幕一樣大
            mikuPlane = new THREE.Mesh(new THREE.PlaneGeometry(window.innerWidth, window.innerHeight), materialMosaic);
            //照mikuPlane的
            cameraMosaic = new THREE.OrthographicCamera(-window.innerWidth / 2, window.innerWidth / 2, window.innerHeight / 2, -window.innerHeight / 2, -100, 100);
            sceneMosaic.add(mikuPlane);
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() {
            /*
                materialMosaic.uniforms.gran.value = gcontrols.gran;
                if (gcontrols.mosaic === false)
                    materialMosaic.uniforms.gran.value = 1;  // finest gran
            */
            requestAnimationFrame(animate);

            headCompute();

            angle += 0.01;
            miku.position.set(80 * Math.cos(angle), 0, -80 * Math.sin(angle));
            miku.rotation.y = Math.PI + angle;

            renderer.setRenderTarget(renderTargetMosaic);
            renderer.render(sceneColor, camera);

            renderer.setRenderTarget(null);
            renderer.render(sceneMosaic, cameraMosaic);
        }

        function headCompute() {
            // compute headNDC
            //人頭正中心
            var headCenter = new THREE.Vector3(0, 40, 0);
            miku.localToWorld(headCenter);
            //頭頂
            var headTop = new THREE.Vector3(0, 40 + 15, 0);
            miku.localToWorld(headTop);
            //找到鼻子在物件中的位置
            var noseTip = new THREE.Vector3(0, 40, -10);
            miku.localToWorld(noseTip);

            //找到頭中心點、鼻子和頭頂的gl_position
            headCenter.applyMatrix4(camera.matrixWorldInverse).applyMatrix4(camera.projectionMatrix);
            //頭的標準化設備座標(x,y)
            //要+1/2是因為NDC是從0~1，而headCenter原本是-1~1
            materialMosaic.uniforms.headNDC.value = new THREE.Vector2((headCenter.x + 1) / 2, (headCenter.y + 1) / 2);
            noseTip.applyMatrix4(camera.matrixWorldInverse).applyMatrix4(camera.projectionMatrix);
            headTop.applyMatrix4(camera.matrixWorldInverse).applyMatrix4(camera.projectionMatrix);
            //往正z方向是越靠前，所以鼻子的z比頭中心的z近，則是看的到臉惹
            if (noseTip.z - headCenter.z > 0) {
                materialMosaic.uniforms.front.value = true;
            } else
                materialMosaic.uniforms.front.value = false;

            materialMosaic.uniforms.gran.value = 0.01;
            materialMosaic.uniforms.headSize.value = 1.2 * headTop.distanceTo(headCenter) / 2;
        }

    </script>
</body>

</html>