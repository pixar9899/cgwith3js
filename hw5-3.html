<!DOCTYPE html>

<html>

<head>
    <title>HW5-3 Using GLSL shaders in a class</title>
    <meta charset="utf-8">
    <link rel="stylesheet" href="vendor/css/bootstrap.min.css">
    <link href="style.css" rel="stylesheet">
    <style>
        #info {
            position: absolute;
            width: 100%;
            text-align: center;
            margin: 0 auto;
            color: #ff0000;
            font-size: 20px;
            z-index: 10;
            padding-top: 2vh;
        }

        #canvas {
            margin: 0 auto;
            display: block;
            position: absolute;
            width: 100%;
            height: 100%;
        }

        #survive {
            display: inline;
        }

        body {
            overflow: hidden;
        }
    </style>
</head>

<body>
    <div id="info">HW5-3 Using GLSL shaders in a class<br>
        <a href="index.html">home</a><br>
        <span style="color: aqua;font-size: 20px;">有<div id="survive"></div>個茶壺在場景中</span>
    </div>
    <div id="canvas"></div>
    <script src="vendor/js/Perlin.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/109/three.min.js"></script>
    <script src="https://threejs.org/examples/js/controls/OrbitControls.js"></script>
    <script src="https://code.jquery.com/jquery-2.1.4.min.js"></script>
    <script src="https://raw.githack.com/mrdoob/three.js/dev/examples/js/geometries/TeapotBufferGeometry.js"></script>
    <script src="vendor/js/text2D.js"></script>

    <script id="teapotVertexShader" type="x-shader/x-vertex">
        uniform int shading;
        uniform int coordinate;
        varying vec3 color;
        varying vec4 objpos;
        varying vec4 worldpos;
        varying vec4 eyepos;

        void perVertexShading(vec3 objpos, vec3 worldpos) {
            if (coordinate == 0) {
                //物件座標
                if (objpos.x > 0.0) 
                    color = vec3 (1,1,1);
                else
                    color = vec3 (0,0,0);
            } else if (coordinate == 1) {
                //世界座標
                if (worldpos.x > 0.0) 
                    color = vec3 (1,1,1);
                else
                    color = vec3 (0,0,0);    	
            } else if (coordinate == 2) {
                //眼睛座標(直接拿varying變數，於main已經算好)
                if (eyepos.x > 0.0) 
                    color = vec3 (1,1,1);
                else
                    color = vec3 (0,0,0);    	
            }
        }
        
        void main() {
            gl_Position = projectionMatrix* modelViewMatrix * vec4(position, 1.0);
            objpos = vec4(position, 1.0);
            worldpos = modelMatrix * vec4(position, 1.0);
            eyepos = modelViewMatrix * vec4(position, 1.0);
            if (shading == 0)  // per-vertex shading
                perVertexShading(position, worldpos.xyz);
        }
    </script>

    <script id="teapotFragmentShader" type="x-shader/x-fragment">
        uniform int shading;
        uniform int coordinate;
        //取得透明度
        uniform float optical;
        //用頂點上的色
        varying vec3 color;

        //傳到fragment像素做處理
        //物件座標
        varying vec4 objpos;
        //世界座標
        varying vec4 worldpos;
        //眼睛座標
        varying vec4 eyepos;

        //要上的色
        vec3 fragcolor;
        void main() {
            if(shading==0){
                //從Vertex下手
                fragcolor = color;
            }else if(shading==1){
                // your homework
                //perPixelShading移到這裡
                //從Pixel下手
                if (coordinate == 0) {
                    if (objpos.x > 0.0) 
                        fragcolor = vec3 (1,1,1);
                    else
                        fragcolor = vec3 (0,0,0);
                } else if (coordinate == 1) {
                    if (worldpos.x > 0.0) 
                        fragcolor = vec3 (1,1,1);
                    else
                        fragcolor = vec3 (0,0,0);    	
                } else if (coordinate == 2) {
                    if (eyepos.x > 0.0) 
                        fragcolor = vec3 (1,1,1);
                    else
                        fragcolor = vec3 (0,0,0);    	
                }
            }
            gl_FragColor = vec4 (fragcolor, optical);
        }
    </script>

    <script>
        //檢查FPS
        javascript: (function () { var script = document.createElement('script'); script.onload = function () { var stats = new Stats(); document.body.appendChild(stats.dom); requestAnimationFrame(function loop() { stats.update(); requestAnimationFrame(loop) }); }; script.src = 'https://mrdoob.github.io/stats.js/build/stats.min.js'; document.head.appendChild(script); })();
        const perlin = new Perlin();
        var scene, renderer, camera;
        var width, height;
        var material;
        var terrain;
        var teapots = [];
        var raycaster;
        var mouse = new THREE.Vector2();
        var pickables = [];
        var clock;
        var poi = new THREE.Vector3();
        var n = new THREE.Vector3();
        var la = new THREE.Vector3();
        /////////////////////////////////////////////////////////////////
        class MyTeaPot {
            //預設每秒轉45度
            static speed = Math.PI * 8;
            static subLife = 0.25;
            static count = 0;

            constructor(point, material) {
                if (material === undefined) {
                    var material = new THREE.ShaderMaterial({
                        uniforms: {
                            lightpos: { type: 'v3', value: new THREE.Vector3(0, 30, 20) },
                            shading: { type: 'i', value: 1 },
                            coordinate: { type: 'i', value: 0 },
                            optical: { type: 'f', value: 1.0 }
                        },
                        vertexShader: document.getElementById('teapotVertexShader').textContent,
                        fragmentShader: document.getElementById('teapotFragmentShader').textContent,
                        transparent: true // important!
                    });
                }
                this.mesh = new THREE.Object3D();
                this.mesh.position.copy(point);
                this.mesh.class = "teapot";
                //放入茶壺
                this.teapot = this.createTeapot(material);
                this.mesh.add(this.teapot);
                //////////////////////////////////////////////////
                this.lifeText = this.createLifeText();
                MyTeaPot.count++;
            }

            createLifeText() {
                let Text2D = THREE_Text.MeshText2D;
                let textAlign = THREE_Text.textAlign;

                let lifeText = new Text2D(this.teapot.life, {
                    align: textAlign.center,
                    font: '12px Arial',
                    fillStyle: '#00ff00',
                    antialias: true
                });
                return lifeText;
            }

            createTeapot(material) {
                let teapotGeom = new THREE.TeapotBufferGeometry(5);
                teapotGeom.translate(0, 0.5, 0);
                //做旋轉，三軸方向已改變
                teapotGeom.rotateX(Math.PI * 0.5);
                //往上-Z，往前+Y，X不變
                ///////////////////////////////////////////////
                let teapot = new THREE.Mesh(teapotGeom, material);
                let box3 = new THREE.Box3();
                box3.setFromObject(teapot);
                let teapotSize = new THREE.Vector3().subVectors(box3.max, box3.min);
                teapot.position.z = teapotSize.z / 2;
                teapot.life = 1;
                return teapot;
            }

            activeTeapot(deltaTime) {
                this.teapot.life -= MyTeaPot.subLife * deltaTime;
                this.teapot.rotation.z -= MyTeaPot.speed * deltaTime * this.teapot.life;
                this.teapot.material.uniforms.optical.value = this.teapot.life;
                this.lifeText.text = (this.teapot.life * 100).toFixed(0);
                if (this.teapot.life >= 0.75)
                    this.lifeText.fillStyle = "#00ff00";
                else if (this.teapot.life < 0.75 && this.teapot.life >= 0.5)
                    this.lifeText.fillStyle = "#ff00ff";
                else if (this.teapot.life < 0.5)
                    this.lifeText.fillStyle = "#ff0000";
            }

            deadTest() {
                if (this.teapot.life <= 0)
                    return true;
                else
                    return false;
            }
        }

        init();
        animate();

        function init() {
            clock = new THREE.Clock();
            width = window.innerWidth;
            height = window.innerHeight;

            renderer = new THREE.WebGLRenderer({
                antialias: true
            });
            renderer.setSize(width, height);
            renderer.setClearColor(0x888888);
            $('#canvas').append(renderer.domElement);

            scene = new THREE.Scene();
            let cube = loadCubemap("vendor/textures", "cubeMap3");
            scene.background = cube;

            camera = new THREE.PerspectiveCamera(45, width / height, 0.1, 10000);
            camera.position.set(0, 200, 500);
            camera.lookAt(new THREE.Vector3(0, 0, 0));

            controls = new THREE.OrbitControls(camera, renderer.domElement);

            pointLight = new THREE.PointLight(0xffffff);
            pointLight.position.set(200, 300, 200);
            scene.add(pointLight);
            var ambientLight = new THREE.AmbientLight(0x111111);
            scene.add(ambientLight);
            /////////////////////////////////////////////////////////////////
            terrain = createTerrain();
            terrain.class = "terrain";
            scene.add(terrain);
            pickables.push(terrain);
            /////////////////////////////////////////////////////////////////
            raycaster = new THREE.Raycaster();
            document.addEventListener('mousedown', onDocumentMouseDown, false);
            document.addEventListener('mousemove', onDocumentMouseOver, false);
            /////////////////////////////////////////////////////////////////
            material = new THREE.ShaderMaterial({
                uniforms: {
                    lightpos: { type: 'v3', value: new THREE.Vector3(0, 30, 20) },
                    shading: { type: 'i', value: 1 },
                    coordinate: { type: 'i', value: 0 },
                    optical: { type: 'f', value: 1.0 }
                },
                vertexShader: document.getElementById('teapotVertexShader').textContent,
                fragmentShader: document.getElementById('teapotFragmentShader').textContent,
                transparent: true // important!
            });
        }

        function createTerrain() {
            //演算法來源：http://www.stephanbaker.com/post/perlinterrain/
            //影片：https://www.youtube.com/watch?v=Or19ilef4wE&t=198s
            let map = new THREE.TextureLoader().load('vendor/textures/grasslight.jpg');
            map.wrapS = THREE.RepeatWrapping;
            map.wrapT = THREE.RepeatWrapping;
            map.repeat.set(20, 20);
            var geometry = new THREE.PlaneBufferGeometry(800, 800, 256, 256);
            var terrainMaterial = new THREE.MeshLambertMaterial({ map: map });
            let terrain = new THREE.Mesh(geometry, terrainMaterial);
            terrain.rotation.x = -Math.PI / 2;
            //峰值
            var peak = 50;
            //平滑化
            var smoothing = 180;
            var vertices = terrain.geometry.attributes.position.array;
            for (var i = 0; i <= vertices.length; i += 3) {
                vertices[i + 2] = peak * perlin.noise(
                    (vertices[i]) / smoothing,
                    (vertices[i + 1]) / smoothing
                );
                // if (i % 3 == 0 && Math.random() >= 0.9) {
                //     let tree = new THREE.Mesh(
                //         new THREE.BoxGeometry(2, 10, 2),
                //         new THREE.MeshNormalMaterial()
                //     );
                //     scene.add(tree);
                //     tree.position.set(-vertices[i], vertices[i + 2], vertices[i + 1]);
                // }
            }
            terrain.geometry.computeVertexNormals();
            return terrain;
        }

        function animate() {
            teapotAnimate();
            ///////////////////////
            $('#survive').text(MyTeaPot.count);
            ///////////////////////
            render();
        }

        function teapotAnimate() {
            let groundShadow = camera.position.clone();
            groundShadow.y = 0;
            ///////////////////////
            //取得目前的時間差，看每個得夠要轉多少角度
            let delta = clock.getDelta();
            teapots.forEach(function (obj, index) {
                //做旋轉與減少生命的動作
                obj.activeTeapot(delta);
                obj.lifeText.lookAt(groundShadow);
                if (obj.deadTest()) {
                    //從場景中移除物件
                    scene.remove(obj.lifeText);
                    scene.remove(obj.mesh);
                    //從陣列中移除物件
                    teapots.splice(index, 1);
                    //從pickalbes移除得夠
                    pickables.forEach(function (pickObj, index) {
                        if (pickObj === obj.mesh) {
                            pickables.splice(index, 1);
                        }
                    });
                    MyTeaPot.count--;
                }
            })
        }

        function render() {
            requestAnimationFrame(animate);
            renderer.render(scene, camera);
        }

        //抓來用...
        function onDocumentMouseDown(event) {
            // PICKING DETAILS: 
            // convert mouse.xy = [-1,1]^2 (NDC)
            // unproject (mouse.xy, 1) to a point on the far plane (in world coordinate)
            // set raycaster (origin, direction)
            // find intersection objects, (closest first) 
            // each record as
            // [ { distance, point, face, faceIndex, object }, ... ]

            event.preventDefault();
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

            // find intersections
            raycaster.setFromCamera(mouse, camera);
            var intersects = raycaster.intersectObjects(pickables, true);
            if (intersects.length > 0) {
                let picked = intersects[0];
                console.log(picked);
                if (picked.object.class == "terrain") {
                    //////////////////////////////
                    let obj = picked.object;
                    poi.copy(picked.point);
                    n.copy(picked.face.normal);
                    n.transformDirection(terrain.matrixWorld);
                    n.multiplyScalar(20);
                    la.copy(poi).add(n);
                    let newTeaPot = new MyTeaPot(poi, new THREE.ShaderMaterial().copy(material));
                    newTeaPot.mesh.lookAt(la);
                    //////////////////////////////
                    teapots.push(newTeaPot);
                    pickables.push(newTeaPot.mesh);
                    scene.add(newTeaPot.mesh);
                    scene.add(newTeaPot.lifeText);
                    newTeaPot.lifeText.position.set(poi.x, poi.y + 20, poi.z);
                } else {
                    //沒有點到山脈就是點到茶壺
                    //這邊的object就是茶壺本身
                    picked.object.life = 1;
                }
            }
        }

        //這個也抓來直接用...
        function onDocumentMouseOver(event) {
            event.preventDefault();  // may not be necessary
            mouse.x = (event.clientX / width) * 2 - 1;
            mouse.y = -(event.clientY / height) * 2 + 1;

            // find intersections
            raycaster.setFromCamera(mouse, camera);
            var intersects = raycaster.intersectObjects(pickables, true);
            if (intersects.length > 0) {
                document.body.style.cursor = 'pointer';
            }
            else {
                document.body.style.cursor = 'auto';
            }
        }

        function loadCubemap(path, folderName) {
            var path = path + "/" + folderName + "/";
            var format = '.png';
            var urls = [
                path + 'posx' + format, path + 'negx' + format,
                path + 'posy' + format, path + 'negy' + format,
                path + 'posz' + format, path + 'negz' + format
            ];
            var loader = new THREE.CubeTextureLoader();
            var cubeMap = loader.load(urls);
            cubeMap.format = THREE.RGBFormat;
            return cubeMap;

        }
    </script>
</body>

</html>