<!DOCTYPE html>

<html>

<head>
    <title>HW5-3 Using GLSL shaders in a class</title>
    <meta charset="utf-8">
    <link rel="stylesheet" href="vendor/css/bootstrap.min.css">
    <link href="style.css" rel="stylesheet">
    <style>
        #info {
            position: absolute;
            width: 100%;
            text-align: center;
            margin: 0 auto;
            color: #ff0000;
            font-size: 20px;
            z-index: 10;
            padding-top: 2vh;
        }

        #canvas {
            margin: 0 auto;
            display: block;
            position: absolute;
            width: 100%;
            height: 100%;
        }

        #survive {
            display: inline;
        }

        body {
            overflow: hidden;
        }
    </style>
</head>

<body>
    <div id="info">HW5-3 Using GLSL shaders in a class<br>
        <a href="index.html">home</a><br>
        <span style="color: aqua;font-size: 20px;">有<div id="survive">0</div>個茶壺在場景中</span><br>
        Shader Type:
        <select id='shader'>
            <option value="doubleColor" selected>DoubleColor</option>
            <option value="matcap">matcap</option>
            <option value="cartoon">cartoon</option>
        </select>
    </div>
    <div id="canvas"></div>
    <script src="vendor/js/Perlin.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/109/three.min.js"></script>
    <script src="https://threejs.org/examples/js/controls/OrbitControls.js"></script>
    <script src="https://code.jquery.com/jquery-2.1.4.min.js"></script>
    <script src="https://raw.githack.com/mrdoob/three.js/dev/examples/js/geometries/TeapotBufferGeometry.js"></script>
    <script src="vendor/js/text2D.js"></script>
    <script id="sem-vs" type="x-shader/x-vertex">
        varying vec2 vN;
        void main() {
            vec3 e = normalize( vec3( modelViewMatrix * vec4( position, 1.0 ) ) );
            vec3 n = normalize( normalMatrix * normal );
            vec3 r = reflect( e, n );
            float m = 2. * sqrt( pow( r.x, 2. ) + pow( r.y, 2. ) + pow( r.z + 1., 2. ) );
            vN = r.xy / m + .5;
            gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1. );
        }
    </script>
    <script id="sem-fs" type="x-shader/x-vertex">
        uniform sampler2D tMatCap;
        varying vec2 vN;
        uniform float opacity;
        void main() {
            vec3 base = texture2D( tMatCap, vN ).rgb;
            gl_FragColor = vec4( base, opacity);
        }
    </script>

    <script id="toonVertexShader" type="x-shader/x-vertex">
        uniform vec3 lightpos;
        varying float ndotl;
        varying vec3 lightdir;
        varying vec3 eyenorm;
        varying vec2 vUv;
      
        void main() {
            gl_Position = projectionMatrix* modelViewMatrix * vec4( position, 1.0);
            vUv = uv;
            //vec4 worldpos = modelMatrix * vec4 (position, 1.0);
            //ndotl = dot (normalize(lightpos.xyz - worldpos.xyz), normal);
            vec4 eyepos = modelViewMatrix * vec4 (position, 1.0);
            vec4 lighteye = viewMatrix * vec4 (lightpos, 1.0);
            lightdir = lighteye.xyz - eyepos.xyz;
            eyenorm = normalMatrix * normal;
        }
    </script>
    <script id="toonFragmentShader" type="x-shader/x-fragment">
        varying float ndotl;
        varying vec3 lightdir;
        varying vec3 eyenorm;
        uniform sampler2D mytex;
        varying vec2 vUv;
        //取得透明度
        uniform float opacity;

        void main() {
            float nn = dot (normalize(lightdir), normalize(eyenorm));
            if (nn > 0.8) {
                nn= 1.0;
            } else if (nn > 0.6) {
                nn = 0.6;
            } else {
                nn = 0.2;
            }

            vec4 texColor = texture2D (mytex, vUv);
            //gl_FragColor = nn*texColor;
            gl_FragColor = vec4 (nn,nn,nn, opacity);
        }
    </script>

    <script id="teapotVertexShader" type="x-shader/x-vertex">
        uniform int shading;
        uniform int coordinate;
        varying vec3 color;
        varying vec4 objpos;
        varying vec4 worldpos;
        varying vec4 eyepos;

        void perVertexShading(vec3 objpos, vec3 worldpos) {
            if (coordinate == 0) {
                //物件座標
                if (objpos.x > 0.0) 
                    color = vec3 (1,1,1);
                else
                    color = vec3 (0,0,0);
            } else if (coordinate == 1) {
                //世界座標
                if (worldpos.x > 0.0) 
                    color = vec3 (1,1,1);
                else
                    color = vec3 (0,0,0);    	
            } else if (coordinate == 2) {
                //眼睛座標(直接拿varying變數，於main已經算好)
                if (eyepos.x > 0.0) 
                    color = vec3 (1,1,1);
                else
                    color = vec3 (0,0,0);    	
            }
        }
        
        void main() {
            gl_Position = projectionMatrix* modelViewMatrix * vec4(position, 1.0);
            objpos = vec4(position, 1.0);
            worldpos = modelMatrix * vec4(position, 1.0);
            eyepos = modelViewMatrix * vec4(position, 1.0);
            if (shading == 0)  // per-vertex shading
                perVertexShading(position, worldpos.xyz);
        }
    </script>

    <script id="teapotFragmentShader" type="x-shader/x-fragment">
        uniform int shading;
        uniform int coordinate;
        //取得透明度
        uniform float opacity;
        //用頂點上的色
        varying vec3 color;

        //傳到fragment像素做處理
        //物件座標
        varying vec4 objpos;
        //世界座標
        varying vec4 worldpos;
        //眼睛座標
        varying vec4 eyepos;

        //要上的色
        vec3 fragcolor;
        void main() {
            if(shading==0){
                //從Vertex下手
                fragcolor = color;
            }else if(shading==1){
                // your homework
                //perPixelShading移到這裡
                //從Pixel下手
                if (coordinate == 0) {
                    if (objpos.x > 0.0) 
                        fragcolor = vec3 (1,1,1);
                    else
                        fragcolor = vec3 (0,0,0);
                } else if (coordinate == 1) {
                    if (worldpos.x > 0.0) 
                        fragcolor = vec3 (1,1,1);
                    else
                        fragcolor = vec3 (0,0,0);    	
                } else if (coordinate == 2) {
                    if (eyepos.x > 0.0) 
                        fragcolor = vec3 (1,1,1);
                    else
                        fragcolor = vec3 (0,0,0);    	
                }
            }
            gl_FragColor = vec4 (fragcolor, opacity);
        }
    </script>

    <script>
        //檢查FPS
        javascript: (function () { var script = document.createElement('script'); script.onload = function () { var stats = new Stats(); document.body.appendChild(stats.dom); requestAnimationFrame(function loop() { stats.update(); requestAnimationFrame(loop) }); }; script.src = 'https://mrdoob.github.io/stats.js/build/stats.min.js'; document.head.appendChild(script); })();
        const perlin = new Perlin();
        var scene, renderer, camera;
        var width, height;
        var terrain;
        var teapots = [];
        var raycaster;
        var mouse = new THREE.Vector2();
        var pickables = [];
        var clock;
        //新建茶壺的位置方向使用
        var poi = new THREE.Vector3();
        var n = new THREE.Vector3();
        var la = new THREE.Vector3();
        var isDragging = false;
        /////////////////////////////////////////////////////////////////
        class MyTeaPot {
            //預設每秒轉45度
            static speed = Math.PI * 12;
            static subLife = 0.1;
            static count = 0;

            constructor(point, material) {
                this.mesh = new THREE.Object3D();
                this.mesh.position.copy(point);
                this.mesh.class = "teapot";
                //放入茶壺
                this.teapot = this.createTeapot(material);
                this.mesh.add(this.teapot);
                //////////////////////////////////////////////////
                this.lifeText = this.createLifeText();
                MyTeaPot.count++;
            }

            createLifeText() {
                let Text2D = THREE_Text.MeshText2D;
                let textAlign = THREE_Text.textAlign;

                let lifeText = new Text2D(this.teapot.life, {
                    align: textAlign.center,
                    font: '15px Arial',
                    fillStyle: '#00ff00',
                    antialias: true
                });
                return lifeText;
            }

            createTeapot(material) {
                let teapotGeom = new THREE.TeapotBufferGeometry(5);
                teapotGeom.translate(0, 0.5, 0);
                //做旋轉，三軸方向已改變
                teapotGeom.rotateX(Math.PI * 0.5);
                //往上-Z，往前+Y，X不變
                ///////////////////////////////////////////////
                let teapot = new THREE.Mesh(teapotGeom, material);
                let box3 = new THREE.Box3();
                box3.setFromObject(teapot);
                let teapotSize = new THREE.Vector3().subVectors(box3.max, box3.min);
                teapot.position.z = teapotSize.z / 2;
                teapot.life = 1;
                return teapot;
            }

            activeTeapot(deltaTime) {
                this.teapot.life -= MyTeaPot.subLife * deltaTime;
                this.teapot.rotation.z -= MyTeaPot.speed * deltaTime * this.teapot.life;
                this.teapot.material.uniforms.opacity.value = this.teapot.life;
                this.lifeText.text = (this.teapot.life * 100).toFixed(0);
                if (this.teapot.life >= 0.75)
                    this.lifeText.fillStyle = "#00ff00";
                else if (this.teapot.life < 0.75 && this.teapot.life >= 0.5)
                    this.lifeText.fillStyle = "#ff00ff";
                else if (this.teapot.life < 0.5)
                    this.lifeText.fillStyle = "#ff0000";
            }

            deadTest() {
                if (this.teapot.life <= 0)
                    return true;
                else
                    return false;
            }
        }

        init();
        animate();

        function init() {
            clock = new THREE.Clock();
            width = window.innerWidth;
            height = window.innerHeight;

            renderer = new THREE.WebGLRenderer({
                antialias: true
            });
            renderer.setSize(width, height);
            renderer.setClearColor(0x888888);
            $('#canvas').append(renderer.domElement);

            scene = new THREE.Scene();
            let cube = loadCubemap("vendor/textures", "cubeMap3");
            scene.background = cube;

            camera = new THREE.PerspectiveCamera(45, width / height, 0.1, 10000);
            camera.position.set(0, 200, 500);
            camera.lookAt(new THREE.Vector3(0, 0, 0));

            controls = new THREE.OrbitControls(camera, renderer.domElement);

            // directional light
            dLight = new THREE.DirectionalLight(0xffffff, 0.5);
            dLight.position.set(0, 500, 0);
            dLight.castShadow = true;
            dLight.shadow.camera.left = -500;
            dLight.shadow.camera.top = -500;
            dLight.shadow.camera.right = 500;
            dLight.shadow.camera.bottom = 500;
            dLight.shadow.camera.near = 1;
            dLight.shadow.camera.far = 1000;
            dLight.target = scene;
            dLight.shadow.mapSize.width = dLight.shadow.mapSize.height = 1024;
            dLight.shadow.bias = -.01;
            dLight.name = 'dirLight';
            scene.add(dLight);
            var ambientLight = new THREE.AmbientLight(0xaaaaaa);
            scene.add(ambientLight);
            /////////////////////////////////////////////////////////////////
            terrain = createTerrain();
            terrain.class = "terrain";
            scene.add(terrain);
            pickables.push(terrain);
            /////////////////////////////////////////////////////////////////
            raycaster = new THREE.Raycaster();
            document.getElementById("canvas").addEventListener('mousedown', onDocumentMouseDown, false);
            document.getElementById("canvas").addEventListener('mousemove', onDocumentMouseMove, false);
            document.getElementById("canvas").addEventListener('mouseup', onDocumentMouseUp, false);
        }

        function createTerrain() {
            //演算法來源：http://www.stephanbaker.com/post/perlinterrain/
            //影片：https://www.youtube.com/watch?v=Or19ilef4wE&t=198s
            let map = new THREE.TextureLoader().load('vendor/textures/grasslight.jpg');
            map.wrapS = THREE.RepeatWrapping;
            map.wrapT = THREE.RepeatWrapping;
            map.repeat.set(20, 20);
            var geometry = new THREE.PlaneBufferGeometry(800, 800, 256, 256);
            var terrainMaterial = new THREE.MeshLambertMaterial({ map: map });
            let terrain = new THREE.Mesh(geometry, terrainMaterial);
            terrain.rotation.x = -Math.PI / 2;
            //峰值
            var peak = 50;
            //平滑化
            var smoothing = 180;
            var vertices = terrain.geometry.attributes.position.array;
            for (var i = 0; i <= vertices.length; i += 3) {
                vertices[i + 2] = peak * perlin.noise(
                    (vertices[i]) / smoothing,
                    (vertices[i + 1]) / smoothing
                );
                //還想種樹
                // if (i % 3 == 0 && Math.random() >= 0.9) {
                //     let tree = new THREE.Mesh(
                //         new THREE.BoxGeometry(2, 10, 2),
                //         new THREE.MeshNormalMaterial()
                //     );
                //     scene.add(tree);
                //     tree.position.set(-vertices[i], vertices[i + 2], vertices[i + 1]);
                // }
            }
            terrain.geometry.computeVertexNormals();
            return terrain;
        }

        function animate() {
            teapotAnimate();
            render();
        }

        function teapotAnimate() {
            let groundShadow = camera.position.clone();
            groundShadow.y = 0;
            ///////////////////////
            //取得目前的時間差，看每個得夠要轉多少角度
            let delta = clock.getDelta();
            teapots.forEach(function (obj, index) {
                //做旋轉與減少生命的動作
                obj.activeTeapot(delta);
                obj.lifeText.lookAt(groundShadow);
                if (obj.deadTest()) {
                    //從場景中移除物件
                    scene.remove(obj.lifeText);
                    scene.remove(obj.mesh);
                    //從陣列中移除物件
                    teapots.splice(index, 1);
                    //從pickalbes移除得夠
                    pickables.forEach(function (pickObj, index) {
                        if (pickObj === obj.mesh) {
                            pickables.splice(index, 1);
                        }
                    });
                    MyTeaPot.count--;
                    $('#survive').text(MyTeaPot.count);
                }
            })
        }

        function render() {
            requestAnimationFrame(animate);
            renderer.render(scene, camera);
        }

        //抓來用...
        function onDocumentMouseUp(event) {
            // PICKING DETAILS: 
            // convert mouse.xy = [-1,1]^2 (NDC)
            // unproject (mouse.xy, 1) to a point on the far plane (in world coordinate)
            // set raycaster (origin, direction)
            // find intersection objects, (closest first) 
            // each record as
            // [ { distance, point, face, faceIndex, object }, ... ]

            event.preventDefault();

            //檢查是否只是轉動場景
            let wasDragging = isDragging;
            isDragging = false;
            //如果是單純點下去才繼續執行
            if (wasDragging) return;

            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

            // find intersections
            raycaster.setFromCamera(mouse, camera);
            var intersects = raycaster.intersectObjects(pickables, true);
            if (intersects.length > 0) {
                let picked = intersects[0];
                if (picked.object.class == "terrain") {
                    //////////////////////////////
                    let obj = picked.object;
                    poi.copy(picked.point);
                    //法線向量(單位向量)
                    n.copy(picked.face.normal);
                    n.transformDirection(terrain.matrixWorld);
                    la.copy(poi).add(n);
                    let shader = $('#shader').val();
                    let newTeaPot = new MyTeaPot(poi, createNewShader(shader));
                    newTeaPot.mesh.lookAt(la);
                    //////////////////////////////
                    teapots.push(newTeaPot);
                    pickables.push(newTeaPot.mesh);
                    scene.add(newTeaPot.mesh);
                    scene.add(newTeaPot.lifeText);
                    newTeaPot.lifeText.position.set(poi.x, poi.y + 20, poi.z);
                    $('#survive').text(MyTeaPot.count);
                } else {
                    //沒有點到山脈就是點到茶壺
                    //這邊的object就是茶壺本身
                    picked.object.life = 1;
                }
            }
        }

        //這個也抓來直接用...
        function onDocumentMouseMove(event) {
            event.preventDefault();  // may not be necessary
            isDragging = true;
            mouse.x = (event.clientX / width) * 2 - 1;
            mouse.y = -(event.clientY / height) * 2 + 1;

            // find intersections
            raycaster.setFromCamera(mouse, camera);
            var intersects = raycaster.intersectObjects(pickables, true);
            if (intersects.length > 0) {
                document.body.style.cursor = 'pointer';
            }
            else {
                document.body.style.cursor = 'auto';
            }
        }

        function onDocumentMouseDown(event) {
            isDragging = false;
        }

        function loadCubemap(path, folderName) {
            var path = path + "/" + folderName + "/";
            var format = '.png';
            var urls = [
                path + 'posx' + format, path + 'negx' + format,
                path + 'posy' + format, path + 'negy' + format,
                path + 'posz' + format, path + 'negz' + format
            ];
            var loader = new THREE.CubeTextureLoader();
            var cubeMap = loader.load(urls);
            cubeMap.format = THREE.RGBFormat;
            return cubeMap;
        }

        function createNewShader(type) {
            let material;
            switch (type) {
                case "doubleColor":
                    //doubleColor
                    material = new THREE.ShaderMaterial({
                        uniforms: {
                            lightpos: { type: 'v3', value: new THREE.Vector3(0, 30, 20) },
                            shading: { type: 'i', value: 1 },
                            coordinate: { type: 'i', value: 0 },
                            opacity: { type: 'f', value: 1.0 }
                        },
                        vertexShader: document.getElementById('teapotVertexShader').textContent,
                        fragmentShader: document.getElementById('teapotFragmentShader').textContent,
                        transparent: true // important!
                    });
                    break;
                case "cartoon":
                    //cartoonShader
                    material = new THREE.ShaderMaterial({
                        uniforms: {
                            lightpos: { type: 'v3', value: new THREE.Vector3(0, 30, 20) },
                            shading: { type: 'i', value: 1 },
                            coordinate: { type: 'i', value: 0 },
                            opacity: { type: 'f', value: 1.0 }
                        },
                        vertexShader: document.getElementById('toonVertexShader').textContent,
                        fragmentShader: document.getElementById('toonFragmentShader').textContent,
                        transparent: true // important!
                    });
                    break;
                case "matcap":
                    let loader = new THREE.TextureLoader();
                    matcapTex = loader.load('vendor/textures/matcap.jpg');
                    //matcapShader
                    material = new THREE.ShaderMaterial({
                        uniforms: {
                            tMatCap: { type: 't', value: matcapTex },
                            opacity: { type: 'f', value: 1.0 }
                        },
                        vertexShader: document.getElementById('sem-vs').textContent,
                        fragmentShader: document.getElementById('sem-fs').textContent,
                        flatShading: THREE.SmoothShading,
                        transparent: true // important!
                    });
                    break;
            }
            return material;
        }
    </script>
</body>

</html>